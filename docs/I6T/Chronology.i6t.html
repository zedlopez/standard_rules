<!doctype html>
<html lang="en">
<meta charset="utf-8">
<head><title>Chronology</title>
  <style>
span.th, span.td { display: table-cell; }
span.td { padding-left: 2rem; }
span.th { width:4rem; text-align: right; }
span.tr { display: table-row;     counter-increment: linenum; }
.pre-lines { font-family: monospace; margin-left: 3rem; line-height: 1.5rem; }
/*span.line_no::before {
    content: counter(linenum);
    text-align: right;
    display: block;
    font-family: monospace;
    font-weight: normal;
}*/
h1 { margin: 0; }
.fixed { font-family: monospace }
.em { font-style: italic; }
.center { text-align: center; }
    body { font-family: sans-serif; margin: 1.5rem 0 3rem 3rem; background-color: #fafaf0; width: 80rem; }
    .pre { font-family: monospace; margin: auto; width: 80rem; }
#front_matter,.text { width: 48rem; }
/* h3 { margin-top: 1.5rem; padding-top: 1.5rem; }*/
.text { border-bottom: .5px solid black; border-top: .5px solid black; margin-top: 1rem;
padding-bottom: .5rem; margin-bottom: 1.5rem; margin-top: 1.75rem; padding-top: .25rem;}
footer { margin-top: 3rem; padding-top: 1rem; border-top: .5px solid black; margin-bottom: 0;}
/*.subtitle { font-weight: bold; font-size: 1.2rem; }*/
.dstring { font-weight: bold;
  color: #095097; }
.sstring { font-weight: bold;
  color: #095097; }
.comment {  
  color: #156D15; } /* #207D20; */
td.content { padding-right: 2rem; vertical-align: top;}
    </style>
</head>
<body>
<header>
<h1>I6 Template Layer</h1>
<div class="subtitle"><a href="http://inform7.com/">Inform 7 6M62</a> &bull; <a href="./index.html">Contents</a> &bull; <a href="./Introduction.i6t.html">Introduction</a> 
&bull; <a href="fn_index.html">Function Index</a> 
&bull; <a href="rules_index.html">Rules Index</a> 
</div><hr></header>
<div id="front_matter">
<h2><a href="./Chronology.i6t.txt">Chronology.i6t</a></h2><h3 id="chronology-scheme-i">Scheme I.</h3><p><p> If source text contains a condition like &quot;if the well has been dry, ...&quot;, then we need to keep a chronological record by testing at every turn whether or not the well is dry: we log whether this is true now, whether it has ever been true, for how many consecutive turns it has been true (to a maximum of 127), and how many times it has become true having just been false (again, to a maximum of 127 times). All this information is packed into a single word, arranged as a 15-bit bitmap: the least significant bit is the state of the condition now (true or false), the next 7 bits are the number of false-to-true &quot;trips&quot; observed over time, and the top 7 bits are the number of consecutive turns on which the condition has been true (&quot;consecutives&quot;). The 16th and most significant bit is unused, so that the state is always positive even in a 16-bit virtual machine &ndash; a convenience since we then don&#39;t need to worry about the effect of signed division and remainder on the bitmap.<p></p><p> There is no need to store a flag for &quot;has this condition ever been true&quot;, because this is equivalent the number of trips being greater than zero. This might look wrong for a condition which is true at start of play &ndash; say, if the well was always dry &ndash; because then its state has never changed from false to true. But in fact when the VM starts up the state word is initially always 0: it&#39;s only when the startup rulebook fires the update chronological records rule (see below) that we first test whether the well is dry, and that forces a trip from false to true if the well is dry at start of play. Therefore, if <em>T</em> is the number of trips for the condition then <em>T=0</em> if and only if the condition has been false from the very start of play. If the condition is true now, then <em>T=1</em> if and only if it has always been so.<p></p><p><h3 id="chronology-present-and-past">Present and Past.</h3><p><p> Each individual condition has its own unique &quot;PT number&quot;, counting upwards from 0 in order of compilation by NI, and a &quot;chronological record&quot; is a word array with a state word as described above for each PT number.<p></p><p> However, we keep not one but two chronological records: one for the situation now, called the &quot;present chronological record&quot;, and one for the situation as it was just before interesting things most recently happened, called the &quot;past chronological record&quot;. If one of those interesting things was that the well ran dry, then in our example the state word for the condition &quot;if the well has been dry&quot; would be different in the two chronological records. We keep two records in order to be able to detect conditions in four different tenses:<p></p><p> (1) Present tense (&quot;if the well is dry&quot;): none of this machinery is used, because we can just test directly instead, so a present tense condition has no PT-number. (2) Past tense (&quot;if the well was dry&quot;): we look at the flag bit in the past chronological record. (3) Perfect tense (&quot;if the well has been dry&quot;): we look at whether or not <em>T &gt; 0</em> in the present chronological record. (4) Past perfect tense (&quot;if the well had been dry&quot;): we look at whether or not <em>T &gt; 0</em> in the past chronological record.<p></p><p> It&#39;s a somewhat ambiguous matter of context in English when the reference time is for past tenses. If somebody comes out into the sunshine and says, &quot;But it was raining,&quot; when does he mean? We would reasonably guess earlier that day, and probably only an hour or two ago, but that&#39;s a contextual judgement made on the basis of our own experience of how rapidly weather changes. The context for Inform source text is always that of actions, so our convention is that the reference time for past tenses is the point just before the current action began. Such key moments &ndash; when things are just about to happen &ndash; are called &quot;chronology points&quot;. There is a CP just before each action begins; there is a CP in the startup process; and there is a CP at the end of each turn, for good measure. CPs happen when somebody calls <span class="fixed"><a href="./Chronology.i6t.html#line82">ChronologyPoint()</a></span>. The action machinery does this directly, while the startup CP and the CP at end of turn happen in the course of the update chronological records rule (below).<p></p><p><h3 id="chronology-chronology-point">Chronology Point.</h3><p><p> This is when the time of reference for past tenses is now: so it is where the past becomes the present. Soon, exciting things will happen, and the present will go on developing, while the past will remain as it was; until things calm down again and we come to another chronology point.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line82">82</span><span class="td">[ ChronologyPoint pt;</span></span>
<span class="tr"><span class="th" id="line83">83</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;for (pt=0:pt&lt;NO_PAST_TENSE_CONDS:pt++)</span></span>
<span class="tr"><span class="th" id="line84">84</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;past_chronological_record--&gt;pt = present_chronological_record--&gt;pt;</span></span>
<span class="tr"><span class="th" id="line85">85</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="chronology-update-chronological-records-rule">Update Chronological Records Rule.</h3><p><p> It might seem odd that a routine to, supposedly, update something would only call another routine called <span class="fixed">TestSinglePastState</span>: but in this setting, any test updates the state, because it changes the number of times something has been found true, and so on.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line94">94</span><span class="td">[ UPDATE_CHRONOLOGICAL_RECORDS_R pt;</span></span>
<span class="tr"><span class="th" id="line95">95</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;for (pt=0: pt&lt;NO_PAST_TENSE_CONDS: pt++) TestSinglePastState(false, pt, true, -1);</span></span>
<span class="tr"><span class="th" id="line96">96</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;ChronologyPoint();</span></span>
<span class="tr"><span class="th" id="line97">97</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line98">98</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="chronology-test-single-past-state">Test Single Past State.</h3><p><p> <span class="fixed">TestSinglePastState</span> is called with four arguments: (a) <span class="fixed">past_flag</span> is true if we want to test a condition like &quot;if the well was dry&quot; or &quot;if the well had been dry&quot;, which concern only the state as it was at the last chronology point &ndash; in other words, the <span class="fixed">past_chronological_record</span>, which we must not change; whereas <span class="fixed">past_flag</span> is false if we want to test a present tense like &quot;if the well is dry&quot; or &quot;if the well has been dry&quot;, because then we deal with the <span class="fixed">present_chronological_record</span> which must be kept continuously updated. (b) <span class="fixed">pt</span> is the PT number for the condition. (c) <span class="fixed">turn_end</span> is true if we are making the test at the end of a turn, as part of the update chronological records rule, and false otherwise. (For these purposes the start of play is a turn end since the UCRR runs then, too.) (d) <span class="fixed">wanted</span> describes what information the function should return, as detailed in its code below.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line117">117</span><span class="td">{-call:Chronology::past_actions_i6_routines}</span></span>
<span class="tr"><span class="th" id="line118">118</span><span class="td">{-call:Chronology::chronology_extents_i6_escape}</span></span>
<span class="tr"><span class="th" id="line119">119</span><span class="td">{-call:Chronology::past_tenses_i6_escape}</span></span>
</div><div class='text'>
<h3 id="chronology-scheme-ii">Scheme II.</h3><p><p> Actions discussed in the past tense &ndash; &quot;if we have taken the ball&quot; or, more subtly, &quot;Instead of waiting for the third turn&quot; (which also refers to the past) &ndash; are handled in a related but simpler way. NI counts such references, just as with other past tense conditions above, but this time stores a state in two simple word arrays: <span class="fixed">TimesActionHasHappened</span> and <span class="fixed">TurnsActionHasBeenHappening</span>.<p></p><p> It might reasonably be asked why we don&#39;t simply use all of the clever machinery above: why have an entirely different system here? One reason is that actions are events and not continuous states of being. &quot;The well is dry&quot; could be true for any extent of time, but &quot;taking the ball&quot; either happens at a given moment or doesn&#39;t: it is not continuously true. We are therefore in the business of counting events, not measuring durations. Another reason is that the point of reference for past tenses is different. It makes no sense to say &quot;if we were looking&quot; because that would mean at a time just before the current action, when actions were probably not happening at all; while &quot;if we had looked&quot; and &quot;if we have looked&quot; would almost always be identical in meaning for the same reason. So we need a much simpler system with just one possible past tense; we don&#39;t need to keep two different states; and we use the extra storage to enable us to count the number of times, and the number of turns, to at least 31767 instead of stopping at 127. (We also generate more legible code to test past tense actions.)<p></p><p><h3 id="chronology-past-action-routines">Past Action Routines.</h3><p><p> Actions can be quite complicated to test even in the present, and this is much more conveniently done in a routine with its own NI-generated stack frame; so each past tense action has its own testing routine, with a name like <span class="fixed">PAPR_41</span>, which returns true or false depending on whether the action is going on now. The word array <span class="fixed">PastActionsI6Routines</span> then contains a null-terminated list of these routines.<p></p><p><h3 id="chronology-track-actions">Track Actions.</h3><p><p> The routine <span class="fixed"><a href="./Chronology.i6t.html#line238">TrackActions</a></span> then updates the two arrays, and is the equivalent for past tense actions of <span class="fixed"><a href="./Chronology.i6t.html#line82">ChronologyPoint</a></span>. It&#39;s called twice for each in-world action: <span class="fixed"><a href="./Chronology.i6t.html#line238">TrackActions(false)</a></span> just as a new action is about to begin, and then <span class="fixed"><a href="./Chronology.i6t.html#line238">TrackActions(true)</a></span> just after it has finished &ndash; note in particular that if action B happens in the middle of action A, for instance because of a try phrase, then the <span class="fixed"><a href="./Chronology.i6t.html#line238">TrackActions(true)</a></span> call for B happens when A is back as the current action. In fact, that&#39;s the point: because it tells us that B was not the main action for the turn, but only a phase which has now passed again.<p></p><p> For each of the action patterns we track, we need to count the number of times such an action has been tried (<strong> not</strong> the number of times it succeeded), and also the number of consecutive turns on which it has been &quot;the&quot; action. The count of the number of tries is unambiguous and easy to keep: it is incremented at the start-of-action call only, and only if the action matches. But the consecutive turn count is more problematic. The user wants to think of actions and turns as synonymous, and to write conditions like &quot;Before going for the third turn&quot;, and we want to play along because that&#39;s a natural phrasing: but actions and turns are not synonymous at all. The rules are therefore:<p></p><p> (1) At the start-of-action call, provided the action is not a silent one, the consecutive turns count is either incremented or zeroed, depending on whether the action matches. Silent actions are ignored because they are almost always knock-on actions tried in the course of other actions, and are certainly not the &quot;main&quot; action of the turn. But the count can be incremented only once in the course of each turn, so that &quot;Instead of taking something for the third turn: ...&quot; cannot happen on the very first turn because TAKE ALL causes three or more take actions. (2) At the readjustment call, provided the action is not a silent one, the consecutive turns count is zeroed if the action does not match.<p></p><p> Why do we zero the count in rule (2)? Well, suppose that the player types OPEN BOX, so that the opening action takes place, and that it causes a further (non-silent) action, say examining the lid: and suppose that the action pattern we track the turn count for is &quot;examining something&quot;. Then the following calls take place:<p></p><p> (a) <span class="fixed"><a href="./Chronology.i6t.html#line238">TrackActions(false)</a></span> while the action is &quot;opening the box&quot;. Turn count zeroed by rule (1). (b) <span class="fixed"><a href="./Chronology.i6t.html#line238">TrackActions(false)</a></span> while the action is &quot;examining the lid&quot;. Turn count incremented by rule (1). (c) <span class="fixed"><a href="./Chronology.i6t.html#line238">TrackActions(true)</a></span> while the action is &quot;opening the box&quot;. Turn count zeroed by rule (2). (d) <span class="fixed"><a href="./Chronology.i6t.html#line238">TrackActions(true)</a></span> while the action is &quot;opening the box&quot;. Turn count zeroed by rule (2).<p></p><p> Thus rule (2) prevents us from counting this turn as the first of a sequence of turns in which examining something was the action, because it wasn&#39;t the main action of the turn.<p></p><p> A further complication is that we need to record the qualification, or not, even of silent actions, because testing rules like<p></p><p> &gt;&gt; Instead of taking the top hat less than three times...<p></p><p> works by checking that (a) we are currently taking the top hat, and (b) have done so fewer than three times before. (b) uses the turn count described above; but (a) cannot simply look to see if that count is positive, since the action might be happening silently and thus not have contributed to the count; so we also record a flag to hold whether the action seems to be happening in this turn, silent or not.<p></p><p> And a still further complication is that out-of-world actions should never affect counts of turns for in-world actions. Thus,<p></p><p> &gt;&gt; Every turn jumping for three turns: say &quot;A demon appears!&quot;<p></p><p> must not have the count to three broken by the player typing SAVE, which causes an out-of-world action but doesn&#39;t use a turn. The simplest way to deal with that would be to make <span class="fixed"><a href="./Chronology.i6t.html#line238">TrackActions</a></span> do nothing when <span class="fixed">oow</span> is set, but then we would get rules like this wrong:<p></p><p> &gt;&gt; Check requesting the pronoun meanings for the first time: ...<p></p><p> because it <strong> does</strong> make sense for OOW actions to have a count of how many times they&#39;ve happened, even though they don&#39;t occur in simulated time. An OOW action can cause its own <span class="fixed">ActionCurrentlyHappeningFlag</span> to be set, but it can&#39;t cause any other action&#39;s flag to be cleared, and nor can it zero the turns count for another action.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line238">238</span><span class="td">[ TrackActions readjust oow i;</span></span>
<span class="tr"><span class="th" id="line239">239</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;for (i=0: PastActionsI6Routines--&gt;i: i++) {</span></span>
<span class="tr"><span class="th" id="line240">240</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((PastActionsI6Routines--&gt;i).call()) {</span></span>
<span class="tr"><span class="th" id="line241">241</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">! Yes, the current action matches action pattern i:</span></span></span>
<span class="tr"><span class="th" id="line242">242</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (readjust) continue;</span></span>
<span class="tr"><span class="th" id="line243">243</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(TimesActionHasHappened--&gt;i)++;</span></span>
<span class="tr"><span class="th" id="line244">244</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (LastTurnActionHappenedOn--&gt;i ~= turns + 5) {</span></span>
<span class="tr"><span class="th" id="line245">245</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LastTurnActionHappenedOn--&gt;i = turns + 5;</span></span>
<span class="tr"><span class="th" id="line246">246</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ActionCurrentlyHappeningFlag-&gt;i = 1;</span></span>
<span class="tr"><span class="th" id="line247">247</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (keep_silent == false)</span></span>
<span class="tr"><span class="th" id="line248">248</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(TurnsActionHasBeenHappening--&gt;i)++;</span></span>
<span class="tr"><span class="th" id="line249">249</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line250">250</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</span></span>
<span class="tr"><span class="th" id="line251">251</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">! No, the current action doesn&#39;t match action pattern i:</span></span></span>
<span class="tr"><span class="th" id="line252">252</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (oow == false) {</span></span>
<span class="tr"><span class="th" id="line253">253</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (keep_silent == false) { TurnsActionHasBeenHappening--&gt;i = 0; }</span></span>
<span class="tr"><span class="th" id="line254">254</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (LastTurnActionHappenedOn--&gt;i ~= turns + 5)</span></span>
<span class="tr"><span class="th" id="line255">255</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ActionCurrentlyHappeningFlag-&gt;i = 0;</span></span>
<span class="tr"><span class="th" id="line256">256</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line257">257</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line258">258</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line259">259</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="chronology-storage">Storage.</h3><p><p> The necessary array allocation.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line265">265</span><span class="td">Array TimesActionHasHappened--&gt;(NO_PAST_TENSE_ACTIONS+1);</span></span>
<span class="tr"><span class="th" id="line266">266</span><span class="td">Array TurnsActionHasBeenHappening--&gt;(NO_PAST_TENSE_ACTIONS+1);</span></span>
<span class="tr"><span class="th" id="line267">267</span><span class="td">Array LastTurnActionHappenedOn--&gt;(NO_PAST_TENSE_ACTIONS+1);</span></span>
<span class="tr"><span class="th" id="line268">268</span><span class="td">Array ActionCurrentlyHappeningFlag-&gt;(NO_PAST_TENSE_ACTIONS+1);</span></span>
<span class="tr"><span class="th" id="line269">269</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line270">270</span><span class="td">Array past_chronological_record--&gt;(NO_PAST_TENSE_CONDS+1);</span></span>
<span class="tr"><span class="th" id="line271">271</span><span class="td">Array present_chronological_record--&gt;(NO_PAST_TENSE_CONDS+1);</span></span>
</div><footer><p><em>From I6T lib 6/12N &copy; Graham Nelson and published under the <a href="https://github.com/zedlopez/standard_rules/blob/main/LICENSE.md">Artistic License 2.0</a>. Distributed with <a href="http://inform7.com/">Inform 7 6M62</a>.</em></p></footer></body></html>
