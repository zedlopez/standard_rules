<!doctype html>
<html lang="en">
<meta charset="utf-8">
<head><title>Lists</title>
  <style>
span.th, span.td { display: table-cell; }
span.td { padding-left: 2rem; }
span.th { width:4rem; text-align: right; }
span.tr { display: table-row;     counter-increment: linenum; }
span.line_no::before {
    content: counter(linenum);
    text-align: right;
    display: block;
    font-family: monospace;
    font-weight: normal;
}

.fixed { font-family: monospace }
.em { font-style: italic; }
.center { text-align: center; }
    body { font-family: sans-serif; margin: 3rem; background-color: #fafaf0; width: 80rem; }
    .pre { font-family: monospace; margin: auto; width: 80rem; }
#front_matter,.text { width: 50rem; }
.text { border-bottom: .5px solid black; border-top: .5px solid black; margin-top: 1rem;
padding-bottom: 1rem; margin-bottom: 2rem; }
    </style>
</head>
<body>
<div id="front_matter">
<h1><a href="./Lists.i6t">Lists</a></h1><h2>Block Format.</h2><p><p> A list is a variable-length array of values all of which have the same kind. (Compare a combination, a fixed-length array of values with possibly different kinds.) The short block for a list is a pointer to the long block. The long block consists of the strong kind ID of the items (not of the list itself!), followed by the number of items, followed by one word for each item.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line15">15</span><span class="td">Constant&nbsp;LIST_ITEM_KOV_F&nbsp;=&nbsp;0;&nbsp;!&nbsp;The&nbsp;kind&nbsp;of&nbsp;the&nbsp;items</span></span>
<span class="tr"><span class="th" id="line16">16</span><span class="td">Constant&nbsp;LIST_LENGTH_F&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;!&nbsp;The&nbsp;number&nbsp;of&nbsp;items</span></span>
<span class="tr"><span class="th" id="line17">17</span><span class="td">Constant&nbsp;LIST_ITEM_BASE&nbsp;=&nbsp;2;&nbsp;&nbsp;!&nbsp;List&nbsp;items&nbsp;begin&nbsp;at&nbsp;this&nbsp;entry</span></span>
<span class="tr"><span class="th" id="line18">18</span><span class="td"></span></span>
</div><div class='text'>
<h2>KOV Support.</h2><p><p> See the <a href="./BlockValues.i6t.html">BlockValues.i6t</a> segment for the specification of the following routines.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line24">24</span><span class="td">[&nbsp;LIST_OF_TY_Support&nbsp;task&nbsp;arg1&nbsp;arg2&nbsp;arg3;</span></span>
<span class="tr"><span class="th" id="line25">25</span><span class="td">&nbsp;switch(task)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line26">26</span><span class="td">&nbsp;&nbsp;CREATE_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;LIST_OF_TY_Create(arg1,&nbsp;arg2);</span></span>
<span class="tr"><span class="th" id="line27">27</span><span class="td">&nbsp;&nbsp;DESTROY_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIST_OF_TY_Destroy(arg1);</span></span>
<span class="tr"><span class="th" id="line28">28</span><span class="td">&nbsp;&nbsp;MAKEMUTABLE_KOVS:&nbsp;return&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line29">29</span><span class="td">&nbsp;&nbsp;COPYKIND_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;LIST_OF_TY_CopyKind(arg1,&nbsp;arg2);</span></span>
<span class="tr"><span class="th" id="line30">30</span><span class="td">&nbsp;&nbsp;COPYQUICK_KOVS:&nbsp;&nbsp;&nbsp;return&nbsp;LIST_OF_TY_QuickCopy(arg1,&nbsp;arg2);</span></span>
<span class="tr"><span class="th" id="line31">31</span><span class="td">&nbsp;&nbsp;COPYSB_KOVS:&nbsp;&nbsp;&nbsp;BlkValueCopySB1(arg1,&nbsp;arg2);</span></span>
<span class="tr"><span class="th" id="line32">32</span><span class="td">&nbsp;&nbsp;KINDDATA_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;LIST_OF_TY_KindData(arg1,&nbsp;arg2);</span></span>
<span class="tr"><span class="th" id="line33">33</span><span class="td">&nbsp;&nbsp;EXTENT_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;BlkValueRead(arg1,&nbsp;LIST_LENGTH_F)&nbsp;+&nbsp;LIST_ITEM_BASE;</span></span>
<span class="tr"><span class="th" id="line34">34</span><span class="td">&nbsp;&nbsp;COPY_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LIST_OF_TY_Copy(arg1,&nbsp;arg2,&nbsp;arg3);</span></span>
<span class="tr"><span class="th" id="line35">35</span><span class="td">&nbsp;&nbsp;COMPARE_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;LIST_OF_TY_Compare(arg1,&nbsp;arg2);</span></span>
<span class="tr"><span class="th" id="line36">36</span><span class="td">&nbsp;&nbsp;HASH_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;LIST_OF_TY_Hash(arg1);</span></span>
<span class="tr"><span class="th" id="line37">37</span><span class="td">&nbsp;&nbsp;DEBUG_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;&nbsp;=&nbsp;{&quot;,&nbsp;(LIST_OF_TY_Say)&nbsp;arg1,&nbsp;&quot;}&nbsp;of&nbsp;kind&nbsp;&quot;,</span></span>
<span class="tr"><span class="th" id="line38">38</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueRead(arg1,&nbsp;LIST_ITEM_KOV_F);</span></span>
<span class="tr"><span class="th" id="line39">39</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line40">40</span><span class="td">&nbsp;!&nbsp;We&nbsp;choose&nbsp;not&nbsp;to&nbsp;respond&nbsp;to:&nbsp;CAST_KOVS,&nbsp;READ_FILE_KOVS,&nbsp;WRITE_FILE_KOVS</span></span>
<span class="tr"><span class="th" id="line41">41</span><span class="td">&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line42">42</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line43">43</span><span class="td"></span></span>
</div><div class='text'>
<h2>Creation.</h2><p><p> Lists are by default created empty but in a block-value with enough capacity to hold 25 items, this being what&#39;s left in a 32-word block once all overheads are taken care of: 4 words are consumed by the header, then 2 more by the list metadata entries below.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line51">51</span><span class="td">[&nbsp;LIST_OF_TY_Create&nbsp;skov&nbsp;sb&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line52">52</span><span class="td">&nbsp;skov&nbsp;=&nbsp;KindBaseTerm(skov,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line53">53</span><span class="td">&nbsp;list&nbsp;=&nbsp;FlexAllocate(27*WORDSIZE,&nbsp;LIST_OF_TY,&nbsp;BLK_FLAG_MULTIPLE&nbsp;+&nbsp;BLK_FLAG_WORD);</span></span>
<span class="tr"><span class="th" id="line54">54</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_KOV_F,&nbsp;skov,&nbsp;true);</span></span>
<span class="tr"><span class="th" id="line55">55</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;0,&nbsp;true);</span></span>
<span class="tr"><span class="th" id="line56">56</span><span class="td">&nbsp;sb&nbsp;=&nbsp;BlkValueCreateSB1(sb,&nbsp;list);</span></span>
<span class="tr"><span class="th" id="line57">57</span><span class="td">&nbsp;return&nbsp;sb;</span></span>
<span class="tr"><span class="th" id="line58">58</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line59">59</span><span class="td"></span></span>
</div><div class='text'>
<h2>Destruction.</h2><p><p> If the list items are themselves block-values, they must all be freed before the list itself can be freed.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line65">65</span><span class="td">[&nbsp;LIST_OF_TY_Destroy&nbsp;list&nbsp;no_items&nbsp;i&nbsp;k;</span></span>
<span class="tr"><span class="th" id="line66">66</span><span class="td">&nbsp;k&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F);</span></span>
<span class="tr"><span class="th" id="line67">67</span><span class="td">&nbsp;if&nbsp;(KOVIsBlockValue(k))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line68">68</span><span class="td">&nbsp;&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line69">69</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=0:&nbsp;i&lt;no_items:&nbsp;i++)&nbsp;BlkValueFree(BlkValueRead(list,&nbsp;i+LIST_ITEM_BASE));</span></span>
<span class="tr"><span class="th" id="line70">70</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line71">71</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line72">72</span><span class="td"></span></span>
</div><div class='text'>
<h2>Copying.</h2><p><p> Again, if the list contains block-values then they must be duplicated rather than bitwise copied as pointers.<p></p><p> Note that we use the pre-copy stage to remember the kind of value stored in the list. Type-checking will make sure this isn&#39;t abused: cases where it&#39;s important include copying the empty list into a list of rooms (it should not as a result acquire the kind &quot;list of values&quot;), or copying a list of people into a list of things (which should remain a list of things.)<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line85">85</span><span class="td">[&nbsp;LIST_OF_TY_CopyKind&nbsp;to&nbsp;from;</span></span>
<span class="tr"><span class="th" id="line86">86</span><span class="td">&nbsp;BlkValueWrite(to,&nbsp;LIST_ITEM_KOV_F,&nbsp;BlkValueRead(from,&nbsp;LIST_ITEM_KOV_F));</span></span>
<span class="tr"><span class="th" id="line87">87</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line88">88</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line89">89</span><span class="td">[&nbsp;LIST_OF_TY_QuickCopy&nbsp;to&nbsp;from;</span></span>
<span class="tr"><span class="th" id="line90">90</span><span class="td">&nbsp;if&nbsp;(BlkValueRead(to,&nbsp;LIST_ITEM_KOV_F)&nbsp;~=&nbsp;BlkValueRead(from,&nbsp;LIST_ITEM_KOV_F))</span></span>
<span class="tr"><span class="th" id="line91">91</span><span class="td">&nbsp;&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line92">92</span><span class="td">&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line93">93</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line94">94</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line95">95</span><span class="td">[&nbsp;LIST_OF_TY_KindData&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line96">96</span><span class="td">&nbsp;return&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F);</span></span>
<span class="tr"><span class="th" id="line97">97</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line98">98</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line99">99</span><span class="td">[&nbsp;LIST_OF_TY_Copy&nbsp;lto&nbsp;lfrom&nbsp;&nbsp;precopied_list_kov&nbsp;no_items&nbsp;i&nbsp;nv&nbsp;bk&nbsp;val&nbsp;splk;</span></span>
<span class="tr"><span class="th" id="line100">100</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(lfrom,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line101">101</span><span class="td">&nbsp;bk&nbsp;=&nbsp;BlkValueRead(lfrom,&nbsp;LIST_ITEM_KOV_F);</span></span>
<span class="tr"><span class="th" id="line102">102</span><span class="td">&nbsp;if&nbsp;(precopied_list_kov&nbsp;~=&nbsp;0&nbsp;or&nbsp;UNKNOWN_TY)</span></span>
<span class="tr"><span class="th" id="line103">103</span><span class="td">&nbsp;&nbsp;BlkValueWrite(lto,&nbsp;LIST_ITEM_KOV_F,&nbsp;precopied_list_kov);</span></span>
<span class="tr"><span class="th" id="line104">104</span><span class="td">&nbsp;else&nbsp;BlkValueWrite(lto,&nbsp;LIST_ITEM_KOV_F,&nbsp;bk);</span></span>
<span class="tr"><span class="th" id="line105">105</span><span class="td">&nbsp;if&nbsp;(KOVIsBlockValue(bk))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line106">106</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=0:&nbsp;i&lt;no_items:&nbsp;i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line107">107</span><span class="td">&nbsp;&nbsp;&nbsp;val&nbsp;=&nbsp;BlkValueRead(lfrom,&nbsp;i+LIST_ITEM_BASE);</span></span>
<span class="tr"><span class="th" id="line108">108</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(precopied_list_kov&nbsp;~=&nbsp;0&nbsp;or&nbsp;UNKNOWN_TY)</span></span>
<span class="tr"><span class="th" id="line109">109</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;nv&nbsp;=&nbsp;BlkValueCreate(precopied_list_kov);</span></span>
<span class="tr"><span class="th" id="line110">110</span><span class="td">&nbsp;&nbsp;&nbsp;else</span></span>
<span class="tr"><span class="th" id="line111">111</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;nv&nbsp;=&nbsp;BlkValueCreate(bk);</span></span>
<span class="tr"><span class="th" id="line112">112</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueCopy(nv,&nbsp;val);</span></span>
<span class="tr"><span class="th" id="line113">113</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(lto,&nbsp;i+LIST_ITEM_BASE,&nbsp;nv);</span></span>
<span class="tr"><span class="th" id="line114">114</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line115">115</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line116">116</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line117">117</span><span class="td"></span></span>
</div><div class='text'>
<h2>Comparison.</h2><p><p> Lists of a given kind of value are always grouped together, in this comparison: but the effect of that is unlikely to be noticed since NI&#39;s type-checker will probably prevent comparisons of lists of differing items in any case. The next criterion is length: a short list precedes a long one. Beyond that, we use the list&#39;s own preferred comparison function to judge the items in turn, stopping as soon as a pair of corresponding items differs: thus we sort lists of equal size in lexicographic order.<p></p><p> Since the comparison function depends only on the KOV, it may seem wasteful of a word of memory to store it in the list, given that we are already storing the KOV in any case. But we do this because comparisons have to be fast: we don&#39;t want to incur the overhead of translating KOV to comparison function.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line133">133</span><span class="td">[&nbsp;LIST_OF_TY_Compare&nbsp;listleft&nbsp;listright&nbsp;delta&nbsp;no_items&nbsp;i&nbsp;cf;</span></span>
<span class="tr"><span class="th" id="line134">134</span><span class="td">&nbsp;delta&nbsp;=&nbsp;BlkValueRead(listleft,&nbsp;LIST_LENGTH_F)&nbsp;-&nbsp;BlkValueRead(listright,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line135">135</span><span class="td">&nbsp;if&nbsp;(delta)&nbsp;return&nbsp;delta;</span></span>
<span class="tr"><span class="th" id="line136">136</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(listleft,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line137">137</span><span class="td">&nbsp;if&nbsp;(no_items&nbsp;==&nbsp;0)&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line138">138</span><span class="td">&nbsp;delta&nbsp;=&nbsp;BlkValueRead(listleft,&nbsp;LIST_ITEM_KOV_F)&nbsp;-&nbsp;BlkValueRead(listright,&nbsp;LIST_ITEM_KOV_F);</span></span>
<span class="tr"><span class="th" id="line139">139</span><span class="td">&nbsp;if&nbsp;(delta)&nbsp;return&nbsp;delta;</span></span>
<span class="tr"><span class="th" id="line140">140</span><span class="td">&nbsp;cf&nbsp;=&nbsp;LIST_OF_TY_ComparisonFn(listleft);</span></span>
<span class="tr"><span class="th" id="line141">141</span><span class="td">&nbsp;if&nbsp;(cf&nbsp;==&nbsp;0&nbsp;or&nbsp;UnsignedCompare)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line142">142</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=0:&nbsp;i&lt;no_items:&nbsp;i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line143">143</span><span class="td">&nbsp;&nbsp;&nbsp;delta&nbsp;=&nbsp;BlkValueRead(listleft,&nbsp;i+LIST_ITEM_BASE)&nbsp;-</span></span>
<span class="tr"><span class="th" id="line144">144</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueRead(listright,&nbsp;i+LIST_ITEM_BASE);</span></span>
<span class="tr"><span class="th" id="line145">145</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(delta)&nbsp;return&nbsp;delta;</span></span>
<span class="tr"><span class="th" id="line146">146</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line147">147</span><span class="td">&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line148">148</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=0:&nbsp;i&lt;no_items:&nbsp;i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line149">149</span><span class="td">&nbsp;&nbsp;&nbsp;delta&nbsp;=&nbsp;cf(BlkValueRead(listleft,&nbsp;i+LIST_ITEM_BASE),</span></span>
<span class="tr"><span class="th" id="line150">150</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueRead(listright,&nbsp;i+LIST_ITEM_BASE));</span></span>
<span class="tr"><span class="th" id="line151">151</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(delta)&nbsp;return&nbsp;delta;</span></span>
<span class="tr"><span class="th" id="line152">152</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line153">153</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line154">154</span><span class="td">&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line155">155</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line156">156</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line157">157</span><span class="td">[&nbsp;LIST_OF_TY_ComparisonFn&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line158">158</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line159">159</span><span class="td">&nbsp;return&nbsp;KOVComparisonFunction(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F));</span></span>
<span class="tr"><span class="th" id="line160">160</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line161">161</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line162">162</span><span class="td">[&nbsp;LIST_OF_TY_Distinguish&nbsp;txb1&nbsp;txb2;</span></span>
<span class="tr"><span class="th" id="line163">163</span><span class="td">&nbsp;if&nbsp;(LIST_OF_TY_Compare(txb1,&nbsp;txb2)&nbsp;==&nbsp;0)&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line164">164</span><span class="td">&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line165">165</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line166">166</span><span class="td"></span></span>
</div><div class='text'>
<h2>Hashing.</h2><p><p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line170">170</span><span class="td">[&nbsp;LIST_OF_TY_Hash&nbsp;list&nbsp;&nbsp;len&nbsp;kov&nbsp;rv&nbsp;i;</span></span>
<span class="tr"><span class="th" id="line171">171</span><span class="td">&nbsp;rv&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line172">172</span><span class="td">&nbsp;len&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line173">173</span><span class="td">&nbsp;kov&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F);</span></span>
<span class="tr"><span class="th" id="line174">174</span><span class="td">&nbsp;for&nbsp;(i=0:&nbsp;i&lt;len:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line175">175</span><span class="td">&nbsp;&nbsp;rv&nbsp;=&nbsp;rv&nbsp;*&nbsp;33&nbsp;+&nbsp;GetHashValue(kov,&nbsp;BlkValueRead(list,&nbsp;i+LIST_ITEM_BASE));</span></span>
<span class="tr"><span class="th" id="line176">176</span><span class="td">&nbsp;return&nbsp;rv;</span></span>
<span class="tr"><span class="th" id="line177">177</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line178">178</span><span class="td"></span></span>
</div><div class='text'>
<h2>Printing.</h2><p><p> Unusually, this function can print the value in one of several formats: 0 for a comma-separated list; 1 for a braced, set-notation list; 2 for a comma-separated list with definite articles, which only makes sense if the list contains objects; 3 for a comma-separated list with indefinite articles. Note that a list in this sense is <strong> not</strong> printed using the <a href="./ListWriter.i6t.html">ListWriter.i6t</a> code for elaborate lists of objects, and it doesn&#39;t use the &quot;listing contents of...&quot; activity in any circumstances.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line189">189</span><span class="td">[&nbsp;LIST_OF_TY_Say&nbsp;list&nbsp;format&nbsp;no_items&nbsp;v&nbsp;i&nbsp;bk;</span></span>
<span class="tr"><span class="th" id="line190">190</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return;</span></span>
<span class="tr"><span class="th" id="line191">191</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line192">192</span><span class="td">&nbsp;bk&nbsp;=&nbsp;KindAtomic(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F));</span></span>
<span class="tr"><span class="th" id="line193">193</span><span class="td">&nbsp;!&nbsp;print&nbsp;no_items,&nbsp;&quot;&nbsp;of&nbsp;kov=&quot;,&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F),&nbsp;&quot;:&quot;;</span></span>
<span class="tr"><span class="th" id="line194">194</span><span class="td">&nbsp;if&nbsp;(format&nbsp;==&nbsp;1)&nbsp;print&nbsp;&quot;{&quot;;</span></span>
<span class="tr"><span class="th" id="line195">195</span><span class="td">&nbsp;for&nbsp;(i=0:i&lt;no_items:i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line196">196</span><span class="td">&nbsp;&nbsp;v&nbsp;=&nbsp;BlkValueRead(list,&nbsp;i+LIST_ITEM_BASE);</span></span>
<span class="tr"><span class="th" id="line197">197</span><span class="td">&nbsp;&nbsp;switch&nbsp;(format)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line198">198</span><span class="td">&nbsp;&nbsp;&nbsp;2:&nbsp;print&nbsp;(the)&nbsp;v;</span></span>
<span class="tr"><span class="th" id="line199">199</span><span class="td">&nbsp;&nbsp;&nbsp;3:&nbsp;print&nbsp;(a)&nbsp;v;</span></span>
<span class="tr"><span class="th" id="line200">200</span><span class="td">&nbsp;&nbsp;&nbsp;default:</span></span>
<span class="tr"><span class="th" id="line201">201</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bk&nbsp;==&nbsp;LIST_OF_TY)&nbsp;LIST_OF_TY_Say(v,&nbsp;1);</span></span>
<span class="tr"><span class="th" id="line202">202</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;((bk&nbsp;==&nbsp;TEXT_TY)&nbsp;&amp;&amp;&nbsp;(format&nbsp;==&nbsp;1))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line203">203</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;~&quot;;&nbsp;PrintKindValuePair(bk,&nbsp;v);&nbsp;print&nbsp;&quot;~&quot;;</span></span>
<span class="tr"><span class="th" id="line204">204</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line205">205</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;PrintKindValuePair(bk,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line206">206</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line207">207</span><span class="td">&nbsp;&nbsp;if&nbsp;(i&lt;no_items-2)&nbsp;print&nbsp;&quot;,&nbsp;&quot;;</span></span>
<span class="tr"><span class="th" id="line208">208</span><span class="td">&nbsp;&nbsp;if&nbsp;(i==no_items-2)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line209">209</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(format&nbsp;==&nbsp;1)&nbsp;print&nbsp;&quot;,&nbsp;&quot;;&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line210">210</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;#ifdef&nbsp;SERIAL_COMMA;&nbsp;if&nbsp;(no_items&nbsp;~=&nbsp;2)&nbsp;print&nbsp;&quot;,&quot;;&nbsp;#endif;</span></span>
<span class="tr"><span class="th" id="line211">211</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;LIST_WRITER_INTERNAL_RM(&#39;C&#39;);</span></span>
<span class="tr"><span class="th" id="line212">212</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line213">213</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line214">214</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line215">215</span><span class="td">&nbsp;if&nbsp;(format&nbsp;==&nbsp;1)&nbsp;print&nbsp;&quot;}&quot;;</span></span>
<span class="tr"><span class="th" id="line216">216</span><span class="td">&nbsp;prior_named_list&nbsp;=&nbsp;no_items;&nbsp;prior_named_list_gender&nbsp;=&nbsp;-1;</span></span>
<span class="tr"><span class="th" id="line217">217</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line218">218</span><span class="td"></span></span>
</div><div class='text'>
<h2>List From Description.</h2><p><p> That completes the compulsory services required for this KOV to function: from here on, the remaining routines provide definitions of stored action-related phrases in the Standard Rules.<p></p><p> Given a description <span class="fixed">D</span> which applies to some objects and not others &ndash; say, &quot;lighted rooms adjacent to the Transport Hub&quot; &ndash; we can cast this into a list of all objects satisfying <span class="fixed">D</span> with the following routine. Slightly wastefully of time, we have to iterate through the objects twice in order first to work out the length of list we will need, and then to transcribe them.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line232">232</span><span class="td">[&nbsp;LIST_OF_TY_Desc&nbsp;list&nbsp;desc&nbsp;kov&nbsp;obj&nbsp;no_items&nbsp;ex&nbsp;len&nbsp;i;</span></span>
<span class="tr"><span class="th" id="line233">233</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line234">234</span><span class="td">&nbsp;ex&nbsp;=&nbsp;BlkValueLBCapacity(list);</span></span>
<span class="tr"><span class="th" id="line235">235</span><span class="td">&nbsp;len&nbsp;=&nbsp;desc(-3);</span></span>
<span class="tr"><span class="th" id="line236">236</span><span class="td">&nbsp;if&nbsp;(len+LIST_ITEM_BASE&nbsp;&gt;&nbsp;ex)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line237">237</span><span class="td">&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(list,&nbsp;len+LIST_ITEM_BASE)&nbsp;==&nbsp;false)</span></span>
<span class="tr"><span class="th" id="line238">238</span><span class="td">&nbsp;&nbsp;&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line239">239</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line240">240</span><span class="td">&nbsp;if&nbsp;(kov)&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_KOV_F,&nbsp;kov);</span></span>
<span class="tr"><span class="th" id="line241">241</span><span class="td">&nbsp;else&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_KOV_F,&nbsp;OBJECT_TY);</span></span>
<span class="tr"><span class="th" id="line242">242</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;len);</span></span>
<span class="tr"><span class="th" id="line243">243</span><span class="td">&nbsp;obj&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line244">244</span><span class="td">&nbsp;for&nbsp;(i=0:&nbsp;i&lt;len:&nbsp;i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line245">245</span><span class="td">&nbsp;&nbsp;obj&nbsp;=&nbsp;desc(-2,&nbsp;obj,&nbsp;i);</span></span>
<span class="tr"><span class="th" id="line246">246</span><span class="td">&nbsp;&nbsp;!&nbsp;print&nbsp;&quot;i&nbsp;=&nbsp;&quot;,&nbsp;i,&nbsp;&quot;&nbsp;and&nbsp;obj&nbsp;=&nbsp;&quot;,&nbsp;obj,&nbsp;&quot;^&quot;;</span></span>
<span class="tr"><span class="th" id="line247">247</span><span class="td">&nbsp;&nbsp;BlkValueWrite(list,&nbsp;i+LIST_ITEM_BASE,&nbsp;obj);</span></span>
<span class="tr"><span class="th" id="line248">248</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line249">249</span><span class="td">&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line250">250</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line251">251</span><span class="td"></span></span>
</div><div class='text'>
<h2>Find Item.</h2><p><p> We test whether a list <span class="fixed">list</span> includes a value equal to <span class="fixed">v</span> or not. Equality here is in the sense of the list&#39;s comparison function: thus for texts or other lists, say, deep comparisons rather than simple pointer comparisons are performed. In other words, one copy of &quot;Alert&quot; is equal to another.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line259">259</span><span class="td">[&nbsp;LIST_OF_TY_FindItem&nbsp;list&nbsp;v&nbsp;i&nbsp;no_items&nbsp;cf;</span></span>
<span class="tr"><span class="th" id="line260">260</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line261">261</span><span class="td">&nbsp;cf&nbsp;=&nbsp;LIST_OF_TY_ComparisonFn(list);</span></span>
<span class="tr"><span class="th" id="line262">262</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line263">263</span><span class="td">&nbsp;if&nbsp;(cf&nbsp;==&nbsp;0&nbsp;or&nbsp;UnsignedCompare)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line264">264</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=0:&nbsp;i&lt;no_items:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line265">265</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(v&nbsp;==&nbsp;BlkValueRead(list,&nbsp;i+LIST_ITEM_BASE))&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line266">266</span><span class="td">&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line267">267</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=0:&nbsp;i&lt;no_items:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line268">268</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(cf(v,&nbsp;BlkValueRead(list,&nbsp;i+LIST_ITEM_BASE))&nbsp;==&nbsp;0)&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line269">269</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line270">270</span><span class="td">&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line271">271</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line272">272</span><span class="td"></span></span>
</div><div class='text'>
<h2>Insert Item.</h2><p><p> The following routine inserts an item into the list. If this would break the size of the current block-value, then we extend by at least enough room to hold at least another 16 entries.<p></p><p> In the call |LIST_OF_TY_InsertItem(list, v, posnflag, posn, nodups)|, only the first two arguments are compulsory. (a) If <span class="fixed">nodups</span> is set, and an item equal to <span class="fixed">v</span> is already present in the list, we return and do nothing. (<span class="fixed">nodups</span> means &quot;no duplicates&quot;.) (b) Otherwise, if <span class="fixed">posnflag</span> is <span class="fixed">false</span>, we append a new entry <span class="fixed">v</span> at the back of the given <span class="fixed">list</span>. (c) Otherwise, when <span class="fixed">posnflag</span> is <span class="fixed">true</span>, <span class="fixed">posn</span> indicates the insertion position, from 1 (before the current first item) to $N+1$ (after the last), where $N$ is the number of items in the list at present.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line289">289</span><span class="td">[&nbsp;LIST_OF_TY_InsertItem&nbsp;list&nbsp;v&nbsp;posnflag&nbsp;posn&nbsp;nodups&nbsp;i&nbsp;no_items&nbsp;ex&nbsp;nv&nbsp;contents_kind;</span></span>
<span class="tr"><span class="th" id="line290">290</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line291">291</span><span class="td">&nbsp;if&nbsp;(nodups&nbsp;&amp;&amp;&nbsp;(LIST_OF_TY_FindItem(list,&nbsp;v)))&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line292">292</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line293">293</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;no_items);&nbsp;!&nbsp;Forces&nbsp;the&nbsp;list&nbsp;to&nbsp;be&nbsp;mutable</span></span>
<span class="tr"><span class="th" id="line294">294</span><span class="td">&nbsp;contents_kind&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F);</span></span>
<span class="tr"><span class="th" id="line295">295</span><span class="td">&nbsp;if&nbsp;((posnflag)&nbsp;&amp;&amp;&nbsp;((posn&lt;1)&nbsp;||&nbsp;(posn&nbsp;&gt;&nbsp;no_items+1)))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line296">296</span><span class="td">&nbsp;&nbsp;print&nbsp;&quot;***&nbsp;Couldn&#39;t&nbsp;add&nbsp;at&nbsp;entry&nbsp;&quot;,&nbsp;posn,&nbsp;&quot;&nbsp;in&nbsp;the&nbsp;list&nbsp;&quot;;</span></span>
<span class="tr"><span class="th" id="line297">297</span><span class="td">&nbsp;&nbsp;LIST_OF_TY_Say(list,&nbsp;true);</span></span>
<span class="tr"><span class="th" id="line298">298</span><span class="td">&nbsp;&nbsp;print&nbsp;&quot;,&nbsp;which&nbsp;has&nbsp;entries&nbsp;in&nbsp;the&nbsp;range&nbsp;1&nbsp;to&nbsp;&quot;,&nbsp;no_items,&nbsp;&quot;&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line299">299</span><span class="td">&nbsp;&nbsp;RunTimeProblem(RTP_LISTRANGEERROR);</span></span>
<span class="tr"><span class="th" id="line300">300</span><span class="td">&nbsp;&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line301">301</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line302">302</span><span class="td">&nbsp;ex&nbsp;=&nbsp;BlkValueLBCapacity(list);</span></span>
<span class="tr"><span class="th" id="line303">303</span><span class="td">&nbsp;if&nbsp;(no_items+LIST_ITEM_BASE+1&nbsp;&gt;&nbsp;ex)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line304">304</span><span class="td">&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(list,&nbsp;ex+16)&nbsp;==&nbsp;false)&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line305">305</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line306">306</span><span class="td">&nbsp;if&nbsp;(KOVIsBlockValue(contents_kind))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line307">307</span><span class="td">&nbsp;&nbsp;nv&nbsp;=&nbsp;BlkValueCreate(contents_kind);</span></span>
<span class="tr"><span class="th" id="line308">308</span><span class="td">&nbsp;&nbsp;BlkValueCopy(nv,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line309">309</span><span class="td">&nbsp;&nbsp;v&nbsp;=&nbsp;nv;</span></span>
<span class="tr"><span class="th" id="line310">310</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line311">311</span><span class="td">&nbsp;if&nbsp;(posnflag)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line312">312</span><span class="td">&nbsp;&nbsp;posn--;</span></span>
<span class="tr"><span class="th" id="line313">313</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=no_items:i&gt;posn:i--)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line314">314</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;i+LIST_ITEM_BASE,</span></span>
<span class="tr"><span class="th" id="line315">315</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueRead(list,&nbsp;i-1+LIST_ITEM_BASE));&nbsp;&nbsp;&nbsp;</span></span>
<span class="tr"><span class="th" id="line316">316</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line317">317</span><span class="td">&nbsp;&nbsp;BlkValueWrite(list,&nbsp;posn+LIST_ITEM_BASE,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line318">318</span><span class="td">&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line319">319</span><span class="td">&nbsp;&nbsp;BlkValueWrite(list,&nbsp;no_items+LIST_ITEM_BASE,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line320">320</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line321">321</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;no_items+1);</span></span>
<span class="tr"><span class="th" id="line322">322</span><span class="td">&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line323">323</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line324">324</span><span class="td"></span></span>
</div><div class='text'>
<h2>Append List.</h2><p><p> Instead of adjoining a single value, we adjoin an entire second list, which must be of a compatible kind of value (something which NI&#39;s type-checking machinery polices for us). Except that we have a list <span class="fixed">more</span> rather than a value <span class="fixed">v</span> to insert, the specification is the same as for <a href="./Lists.i6t.html#line289">LIST_OF_TY_InsertItem</a>.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line333">333</span><span class="td">[&nbsp;LIST_OF_TY_AppendList&nbsp;list&nbsp;more&nbsp;posnflag&nbsp;posn&nbsp;nodups&nbsp;v&nbsp;i&nbsp;j&nbsp;no_items&nbsp;msize&nbsp;ex&nbsp;nv;</span></span>
<span class="tr"><span class="th" id="line334">334</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line335">335</span><span class="td">&nbsp;if&nbsp;((more==0)&nbsp;||&nbsp;(BlkValueWeakKind(more)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line336">336</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line337">337</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;no_items);&nbsp;!&nbsp;Forces&nbsp;the&nbsp;list&nbsp;to&nbsp;be&nbsp;mutable</span></span>
<span class="tr"><span class="th" id="line338">338</span><span class="td">&nbsp;if&nbsp;((posnflag)&nbsp;&amp;&amp;&nbsp;((posn&lt;1)&nbsp;||&nbsp;(posn&nbsp;&gt;&nbsp;no_items+1)))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line339">339</span><span class="td">&nbsp;&nbsp;print&nbsp;&quot;***&nbsp;Couldn&#39;t&nbsp;add&nbsp;at&nbsp;entry&nbsp;&quot;,&nbsp;posn,&nbsp;&quot;&nbsp;in&nbsp;the&nbsp;list&nbsp;&quot;;</span></span>
<span class="tr"><span class="th" id="line340">340</span><span class="td">&nbsp;&nbsp;LIST_OF_TY_Say(list,&nbsp;true);</span></span>
<span class="tr"><span class="th" id="line341">341</span><span class="td">&nbsp;&nbsp;print&nbsp;&quot;,&nbsp;which&nbsp;has&nbsp;entries&nbsp;in&nbsp;the&nbsp;range&nbsp;1&nbsp;to&nbsp;&quot;,&nbsp;no_items,&nbsp;&quot;&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line342">342</span><span class="td">&nbsp;&nbsp;RunTimeProblem(RTP_LISTRANGEERROR);</span></span>
<span class="tr"><span class="th" id="line343">343</span><span class="td">&nbsp;&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line344">344</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line345">345</span><span class="td">&nbsp;msize&nbsp;=&nbsp;BlkValueRead(more,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line346">346</span><span class="td">&nbsp;ex&nbsp;=&nbsp;BlkValueLBCapacity(list);</span></span>
<span class="tr"><span class="th" id="line347">347</span><span class="td">&nbsp;if&nbsp;(no_items+msize+LIST_ITEM_BASE&nbsp;&gt;&nbsp;ex)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line348">348</span><span class="td">&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(list,&nbsp;no_items+msize+LIST_ITEM_BASE+8)&nbsp;==&nbsp;false)</span></span>
<span class="tr"><span class="th" id="line349">349</span><span class="td">&nbsp;&nbsp;&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line350">350</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line351">351</span><span class="td">&nbsp;if&nbsp;(posnflag)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line352">352</span><span class="td">&nbsp;&nbsp;posn--;</span></span>
<span class="tr"><span class="th" id="line353">353</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=no_items+msize:i&gt;=posn+msize:i--)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line354">354</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;i+LIST_ITEM_BASE,</span></span>
<span class="tr"><span class="th" id="line355">355</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueRead(list,&nbsp;i-msize+LIST_ITEM_BASE));&nbsp;&nbsp;&nbsp;</span></span>
<span class="tr"><span class="th" id="line356">356</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line357">357</span><span class="td">&nbsp;&nbsp;!&nbsp;BlkValueWrite(list,&nbsp;posn,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line358">358</span><span class="td">&nbsp;&nbsp;for&nbsp;(j=0:&nbsp;j&lt;msize:&nbsp;j++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line359">359</span><span class="td">&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;BlkValueRead(more,&nbsp;j+LIST_ITEM_BASE);</span></span>
<span class="tr"><span class="th" id="line360">360</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(KOVIsBlockValue(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F)))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line361">361</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;nv&nbsp;=&nbsp;BlkValueCreate(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F));</span></span>
<span class="tr"><span class="th" id="line362">362</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueCopy(nv,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line363">363</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;nv;</span></span>
<span class="tr"><span class="th" id="line364">364</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line365">365</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;posn+j+LIST_ITEM_BASE,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line366">366</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line367">367</span><span class="td">&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line368">368</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=0,&nbsp;j=0:&nbsp;i&lt;msize:&nbsp;i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line369">369</span><span class="td">&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;BlkValueRead(more,&nbsp;i+LIST_ITEM_BASE);</span></span>
<span class="tr"><span class="th" id="line370">370</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(KOVIsBlockValue(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F)))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line371">371</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;nv&nbsp;=&nbsp;BlkValueCreate(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F));</span></span>
<span class="tr"><span class="th" id="line372">372</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueCopy(nv,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line373">373</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;nv;</span></span>
<span class="tr"><span class="th" id="line374">374</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line375">375</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;((nodups&nbsp;==&nbsp;0)&nbsp;||&nbsp;(LIST_OF_TY_FindItem(list,&nbsp;v)&nbsp;==&nbsp;false))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line376">376</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;no_items+j+LIST_ITEM_BASE,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line377">377</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;j++;</span></span>
<span class="tr"><span class="th" id="line378">378</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line379">379</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line380">380</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line381">381</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;no_items+j);</span></span>
<span class="tr"><span class="th" id="line382">382</span><span class="td">&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line383">383</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line384">384</span><span class="td"></span></span>
</div><div class='text'>
<h2>Remove Value.</h2><p><p> We remove every instance of the value <span class="fixed">v</span> from the given <span class="fixed">list</span>. If the optional flag <span class="fixed">forgive</span> is set, then we make no complaint if no value of <span class="fixed">v</span> was present in the first place: otherwise, we issue a run-time problem.<p></p><p> Note that if the list contains block-values then the value must be properly destroyed with <a href="./BlockValues.i6t.html#line632">BlkValueFree</a> before being overwritten as the items shuffle down.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line394">394</span><span class="td">[&nbsp;LIST_OF_TY_RemoveValue&nbsp;list&nbsp;v&nbsp;forgive&nbsp;i&nbsp;j&nbsp;no_items&nbsp;odsize&nbsp;f&nbsp;cf&nbsp;delendum;</span></span>
<span class="tr"><span class="th" id="line395">395</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line396">396</span><span class="td">&nbsp;cf&nbsp;=&nbsp;LIST_OF_TY_ComparisonFn(list);</span></span>
<span class="tr"><span class="th" id="line397">397</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);&nbsp;odsize&nbsp;=&nbsp;no_items;</span></span>
<span class="tr"><span class="th" id="line398">398</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;no_items);&nbsp;!&nbsp;Forces&nbsp;the&nbsp;list&nbsp;to&nbsp;be&nbsp;mutable</span></span>
<span class="tr"><span class="th" id="line399">399</span><span class="td">&nbsp;for&nbsp;(i=0:&nbsp;i&lt;no_items:&nbsp;i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line400">400</span><span class="td">&nbsp;&nbsp;delendum&nbsp;=&nbsp;BlkValueRead(list,&nbsp;i+LIST_ITEM_BASE);</span></span>
<span class="tr"><span class="th" id="line401">401</span><span class="td">&nbsp;&nbsp;if&nbsp;(cf&nbsp;==&nbsp;0&nbsp;or&nbsp;UnsignedCompare)</span></span>
<span class="tr"><span class="th" id="line402">402</span><span class="td">&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;(v&nbsp;==&nbsp;delendum);</span></span>
<span class="tr"><span class="th" id="line403">403</span><span class="td">&nbsp;&nbsp;else</span></span>
<span class="tr"><span class="th" id="line404">404</span><span class="td">&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;(cf(v,&nbsp;delendum)&nbsp;==&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line405">405</span><span class="td">&nbsp;&nbsp;if&nbsp;(f)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line406">406</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(KOVIsBlockValue(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F)))</span></span>
<span class="tr"><span class="th" id="line407">407</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueFree(delendum);</span></span>
<span class="tr"><span class="th" id="line408">408</span><span class="td">&nbsp;&nbsp;&nbsp;for&nbsp;(j=i+1:&nbsp;j&lt;no_items:&nbsp;j++)</span></span>
<span class="tr"><span class="th" id="line409">409</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;j-1+LIST_ITEM_BASE,</span></span>
<span class="tr"><span class="th" id="line410">410</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueRead(list,&nbsp;j+LIST_ITEM_BASE));</span></span>
<span class="tr"><span class="th" id="line411">411</span><span class="td">&nbsp;&nbsp;&nbsp;no_items--;&nbsp;i--;</span></span>
<span class="tr"><span class="th" id="line412">412</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;no_items);</span></span>
<span class="tr"><span class="th" id="line413">413</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line414">414</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line415">415</span><span class="td">&nbsp;if&nbsp;(odsize&nbsp;~=&nbsp;no_items)&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line416">416</span><span class="td">&nbsp;if&nbsp;(forgive)&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line417">417</span><span class="td">&nbsp;print&nbsp;&quot;***&nbsp;Couldn&#39;t&nbsp;remove:&nbsp;the&nbsp;value&nbsp;&quot;;</span></span>
<span class="tr"><span class="th" id="line418">418</span><span class="td">&nbsp;PrintKindValuePair(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F),&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line419">419</span><span class="td">&nbsp;print&nbsp;&quot;&nbsp;was&nbsp;not&nbsp;present&nbsp;in&nbsp;the&nbsp;list&nbsp;&quot;;</span></span>
<span class="tr"><span class="th" id="line420">420</span><span class="td">&nbsp;LIST_OF_TY_Say(list,&nbsp;true);</span></span>
<span class="tr"><span class="th" id="line421">421</span><span class="td">&nbsp;print&nbsp;&quot;&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line422">422</span><span class="td">&nbsp;RunTimeProblem(RTP_LISTRANGEERROR);</span></span>
<span class="tr"><span class="th" id="line423">423</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line424">424</span><span class="td"></span></span>
</div><div class='text'>
<h2>Remove Item Range.</h2><p><p> We excise items <span class="fixed">from</span> to <span class="fixed">to</span> from the given <span class="fixed">list</span>, which numbers its items upwards from 1. If the optional flag <span class="fixed">forgive</span> is set, then we truncate a range overspilling the actual list, and we make no complaint if it turns out that there is then nothing to be done: otherwise, in either event, we issue a run-time problem.<p></p><p> Once again, we destroy any block-values whose pointers will be overwritten as the list shuffles down to fill the void.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line436">436</span><span class="td">[&nbsp;LIST_OF_TY_RemoveItemRange&nbsp;list&nbsp;from&nbsp;to&nbsp;forgive&nbsp;i&nbsp;d&nbsp;no_items;</span></span>
<span class="tr"><span class="th" id="line437">437</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line438">438</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line439">439</span><span class="td">&nbsp;if&nbsp;((from&nbsp;&gt;&nbsp;to)&nbsp;||&nbsp;(from&nbsp;&lt;=&nbsp;0)&nbsp;||&nbsp;(to&nbsp;&gt;&nbsp;no_items))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line440">440</span><span class="td">&nbsp;&nbsp;if&nbsp;(forgive)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line441">441</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(from&nbsp;&lt;=&nbsp;0)&nbsp;from&nbsp;=&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line442">442</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(to&nbsp;&gt;=&nbsp;no_items)&nbsp;to&nbsp;=&nbsp;no_items;</span></span>
<span class="tr"><span class="th" id="line443">443</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(from&nbsp;&gt;&nbsp;to)&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line444">444</span><span class="td">&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line445">445</span><span class="td">&nbsp;&nbsp;&nbsp;print&nbsp;&quot;***&nbsp;Couldn&#39;t&nbsp;remove&nbsp;entries&nbsp;&quot;,&nbsp;from,&nbsp;&quot;&nbsp;to&nbsp;&quot;,&nbsp;to,&nbsp;&quot;&nbsp;from&nbsp;the&nbsp;list&nbsp;&quot;;</span></span>
<span class="tr"><span class="th" id="line446">446</span><span class="td">&nbsp;&nbsp;&nbsp;LIST_OF_TY_Say(list,&nbsp;true);</span></span>
<span class="tr"><span class="th" id="line447">447</span><span class="td">&nbsp;&nbsp;&nbsp;print&nbsp;&quot;,&nbsp;which&nbsp;has&nbsp;entries&nbsp;in&nbsp;the&nbsp;range&nbsp;1&nbsp;to&nbsp;&quot;,&nbsp;no_items,&nbsp;&quot;&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line448">448</span><span class="td">&nbsp;&nbsp;&nbsp;RunTimeProblem(RTP_LISTRANGEERROR);</span></span>
<span class="tr"><span class="th" id="line449">449</span><span class="td">&nbsp;&nbsp;&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line450">450</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line451">451</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line452">452</span><span class="td">&nbsp;to--;&nbsp;from--;</span></span>
<span class="tr"><span class="th" id="line453">453</span><span class="td">&nbsp;d&nbsp;=&nbsp;to-from+1;</span></span>
<span class="tr"><span class="th" id="line454">454</span><span class="td">&nbsp;if&nbsp;(KOVIsBlockValue(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F)))</span></span>
<span class="tr"><span class="th" id="line455">455</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=0:&nbsp;i&lt;d:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line456">456</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueFree(BlkValueRead(list,&nbsp;from+i+LIST_ITEM_BASE));</span></span>
<span class="tr"><span class="th" id="line457">457</span><span class="td">&nbsp;for&nbsp;(i=from:&nbsp;i&lt;no_items-d:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line458">458</span><span class="td">&nbsp;&nbsp;BlkValueWrite(list,&nbsp;i+LIST_ITEM_BASE,</span></span>
<span class="tr"><span class="th" id="line459">459</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueRead(list,&nbsp;i+d+LIST_ITEM_BASE));</span></span>
<span class="tr"><span class="th" id="line460">460</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;no_items-d);</span></span>
<span class="tr"><span class="th" id="line461">461</span><span class="td">&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line462">462</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line463">463</span><span class="td"></span></span>
</div><div class='text'>
<h2>Remove List.</h2><p><p> We excise all values from the removal list <span class="fixed">rlist</span>, wherever they occur in <span class="fixed">list</span>. Inevitably, given that we haven&#39;t sorted these lists and can spare neither time nor storage to do so, this is an expensive process with a running time proportional to the product of the two list sizes: we accept that as an overhead because in practice the <span class="fixed">rlist</span> is almost always small in real-world use.<p></p><p> If the initial lists were disjoint, so that no removals occur, we always forgive the user: the request was not necessarily a foolish one, it only happened in this situation to be unhelpful.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line477">477</span><span class="td">[&nbsp;LIST_OF_TY_Remove_List&nbsp;list&nbsp;rlist&nbsp;i&nbsp;j&nbsp;k&nbsp;v&nbsp;w&nbsp;no_items&nbsp;odsize&nbsp;rsize&nbsp;cf&nbsp;f;</span></span>
<span class="tr"><span class="th" id="line478">478</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line479">479</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);&nbsp;odsize&nbsp;=&nbsp;no_items;</span></span>
<span class="tr"><span class="th" id="line480">480</span><span class="td">&nbsp;rsize&nbsp;=&nbsp;BlkValueRead(rlist,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line481">481</span><span class="td">&nbsp;cf&nbsp;=&nbsp;LIST_OF_TY_ComparisonFn(list);</span></span>
<span class="tr"><span class="th" id="line482">482</span><span class="td">&nbsp;for&nbsp;(i=0:&nbsp;i&lt;no_items:&nbsp;i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line483">483</span><span class="td">&nbsp;&nbsp;v&nbsp;=&nbsp;BlkValueRead(list,&nbsp;i+LIST_ITEM_BASE);</span></span>
<span class="tr"><span class="th" id="line484">484</span><span class="td">&nbsp;&nbsp;for&nbsp;(k=0:&nbsp;k&lt;rsize:&nbsp;k++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line485">485</span><span class="td">&nbsp;&nbsp;&nbsp;w&nbsp;=&nbsp;BlkValueRead(rlist,&nbsp;k+LIST_ITEM_BASE);</span></span>
<span class="tr"><span class="th" id="line486">486</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(cf&nbsp;==&nbsp;0&nbsp;or&nbsp;UnsignedCompare)</span></span>
<span class="tr"><span class="th" id="line487">487</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;(v&nbsp;==&nbsp;w);</span></span>
<span class="tr"><span class="th" id="line488">488</span><span class="td">&nbsp;&nbsp;&nbsp;else</span></span>
<span class="tr"><span class="th" id="line489">489</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;(cf(v,&nbsp;w)&nbsp;==&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line490">490</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(f)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line491">491</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(KOVIsBlockValue(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F)))</span></span>
<span class="tr"><span class="th" id="line492">492</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueFree(v);</span></span>
<span class="tr"><span class="th" id="line493">493</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j=i+1:&nbsp;j&lt;no_items:&nbsp;j++)</span></span>
<span class="tr"><span class="th" id="line494">494</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;j+LIST_ITEM_BASE-1,&nbsp;</span></span>
<span class="tr"><span class="th" id="line495">495</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueRead(list,&nbsp;j+LIST_ITEM_BASE));</span></span>
<span class="tr"><span class="th" id="line496">496</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;no_items--;&nbsp;i--;</span></span>
<span class="tr"><span class="th" id="line497">497</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;no_items);</span></span>
<span class="tr"><span class="th" id="line498">498</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line499">499</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line500">500</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line501">501</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line502">502</span><span class="td">&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line503">503</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line504">504</span><span class="td"></span></span>
</div><div class='text'>
<h2>Get Length.</h2><p><p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line508">508</span><span class="td">[&nbsp;LIST_OF_TY_GetLength&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line509">509</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line510">510</span><span class="td">&nbsp;return&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line511">511</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line512">512</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line513">513</span><span class="td">[&nbsp;LIST_OF_TY_Empty&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line514">514</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line515">515</span><span class="td">&nbsp;if&nbsp;(BlkValueRead(list,&nbsp;LIST_LENGTH_F)&nbsp;==&nbsp;0)&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line516">516</span><span class="td">&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line517">517</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line518">518</span><span class="td"></span></span>
</div><div class='text'>
<h2>Set Length.</h2><p><p> This is rather harder: it might lengthen the list, in which case we have to pad out with the default value for the kind of value stored &ndash; padding a list of numbers with 0s, a list of texts with copies of the empty text, and so on &ndash; creating such block-values as might be needed; or else it might shorten the list, in which case we must cut items, destroying them properly if they were block-values.<p></p><p> |LIST_OF_TY_SetLength(list, newsize, this_way_only, truncation_end)| alters the length of the given <span class="fixed">list</span> to <span class="fixed">newsize</span>. If <span class="fixed">this_way_only</span> is 1, the list is only allowed to grow, and nothing happens if we have asked to shrink it; if it is $-1$, the list is only allowed to shrink; if it is 0, the list is allowed either to grow or shrink. In the event that the list does have to shrink, entries must be removed, and we remove from the end if <span class="fixed">truncation_end</span> is 1, or from the start if it is $-1$.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line536">536</span><span class="td">[&nbsp;LIST_OF_TY_SetLength&nbsp;list&nbsp;newsize&nbsp;this_way_only&nbsp;truncation_end&nbsp;no_items&nbsp;ex&nbsp;i&nbsp;dv;</span></span>
<span class="tr"><span class="th" id="line537">537</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line538">538</span><span class="td">&nbsp;if&nbsp;(newsize&nbsp;&lt;&nbsp;0)&nbsp;return&nbsp;RunTimeProblem(RTP_LISTSIZENEGATIVE,&nbsp;newsize);</span></span>
<span class="tr"><span class="th" id="line539">539</span><span class="td">&nbsp;BlkMakeMutable(list);</span></span>
<span class="tr"><span class="th" id="line540">540</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line541">541</span><span class="td">&nbsp;if&nbsp;(no_items&nbsp;&lt;&nbsp;newsize)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line542">542</span><span class="td">&nbsp;&nbsp;if&nbsp;(this_way_only&nbsp;==&nbsp;-1)&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line543">543</span><span class="td">&nbsp;&nbsp;ex&nbsp;=&nbsp;BlkValueLBCapacity(list);</span></span>
<span class="tr"><span class="th" id="line544">544</span><span class="td">&nbsp;&nbsp;if&nbsp;(newsize+LIST_ITEM_BASE&nbsp;&gt;&nbsp;ex)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line545">545</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(list,&nbsp;newsize+LIST_ITEM_BASE)&nbsp;==&nbsp;false)</span></span>
<span class="tr"><span class="th" id="line546">546</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line547">547</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line548">548</span><span class="td">&nbsp;&nbsp;dv&nbsp;=&nbsp;DefaultValueOfKOV(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F));</span></span>
<span class="tr"><span class="th" id="line549">549</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=no_items:&nbsp;i&lt;newsize:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line550">550</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+i,&nbsp;dv);</span></span>
<span class="tr"><span class="th" id="line551">551</span><span class="td">&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;newsize);</span></span>
<span class="tr"><span class="th" id="line552">552</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line553">553</span><span class="td">&nbsp;if&nbsp;(no_items&nbsp;&gt;&nbsp;newsize)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line554">554</span><span class="td">&nbsp;&nbsp;if&nbsp;(this_way_only&nbsp;==&nbsp;1)&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line555">555</span><span class="td">&nbsp;&nbsp;if&nbsp;(truncation_end&nbsp;==&nbsp;-1)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line556">556</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(KOVIsBlockValue(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F)))</span></span>
<span class="tr"><span class="th" id="line557">557</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0:&nbsp;i&lt;no_items-newsize:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line558">558</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueFree(BlkValueRead(list,&nbsp;LIST_ITEM_BASE+i));</span></span>
<span class="tr"><span class="th" id="line559">559</span><span class="td">&nbsp;&nbsp;&nbsp;for&nbsp;(i=0:&nbsp;i&lt;newsize:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line560">560</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+i,</span></span>
<span class="tr"><span class="th" id="line561">561</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+no_items-newsize+i));</span></span>
<span class="tr"><span class="th" id="line562">562</span><span class="td">&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line563">563</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(KOVIsBlockValue(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F)))</span></span>
<span class="tr"><span class="th" id="line564">564</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=newsize:&nbsp;i&lt;no_items:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line565">565</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueFree(BlkValueRead(list,&nbsp;LIST_ITEM_BASE+i));</span></span>
<span class="tr"><span class="th" id="line566">566</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line567">567</span><span class="td">&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_LENGTH_F,&nbsp;newsize);</span></span>
<span class="tr"><span class="th" id="line568">568</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line569">569</span><span class="td">&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line570">570</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line571">571</span><span class="td"></span></span>
</div><div class='text'>
<h2>Get Item.</h2><p><p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line575">575</span><span class="td">[&nbsp;LIST_OF_TY_GetItem&nbsp;list&nbsp;i&nbsp;forgive&nbsp;no_items;</span></span>
<span class="tr"><span class="th" id="line576">576</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line577">577</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line578">578</span><span class="td">&nbsp;if&nbsp;((i&lt;=0)&nbsp;||&nbsp;(i&gt;no_items))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line579">579</span><span class="td">&nbsp;&nbsp;if&nbsp;(forgive)&nbsp;return&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line580">580</span><span class="td">&nbsp;&nbsp;print&nbsp;&quot;***&nbsp;Couldn&#39;t&nbsp;read&nbsp;from&nbsp;entry&nbsp;&quot;,&nbsp;i,&nbsp;&quot;&nbsp;of&nbsp;a&nbsp;list&nbsp;which&quot;;</span></span>
<span class="tr"><span class="th" id="line581">581</span><span class="td">&nbsp;&nbsp;switch&nbsp;(no_items)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line582">582</span><span class="td">&nbsp;&nbsp;&nbsp;0:&nbsp;print&nbsp;&quot;&nbsp;is&nbsp;empty&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line583">583</span><span class="td">&nbsp;&nbsp;&nbsp;1:&nbsp;print&nbsp;&quot;&nbsp;has&nbsp;only&nbsp;one&nbsp;entry,&nbsp;numbered&nbsp;1&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line584">584</span><span class="td">&nbsp;&nbsp;&nbsp;default:&nbsp;print&nbsp;&quot;&nbsp;has&nbsp;entries&nbsp;numbered&nbsp;from&nbsp;1&nbsp;to&nbsp;&quot;,&nbsp;no_items,&nbsp;&quot;&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line585">585</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line586">586</span><span class="td">&nbsp;&nbsp;RunTimeProblem(RTP_LISTRANGEERROR);</span></span>
<span class="tr"><span class="th" id="line587">587</span><span class="td">&nbsp;&nbsp;if&nbsp;(no_items&nbsp;&gt;=&nbsp;1)&nbsp;i&nbsp;=&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line588">588</span><span class="td">&nbsp;&nbsp;else&nbsp;return&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line589">589</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line590">590</span><span class="td">&nbsp;return&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+i-1);</span></span>
<span class="tr"><span class="th" id="line591">591</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line592">592</span><span class="td"></span></span>
</div><div class='text'>
<h2>Write Item.</h2><p><p> The slightly odd name for this function comes about because our usual way to convert an rvalue such as |LIST_OF_TY_GetItem(L, 4)| is to prefix <span class="fixed">Write</span>, so that it becomes |WriteLIST_OF_TY_GetItem(L, 4)|.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line599">599</span><span class="td">[&nbsp;WriteLIST_OF_TY_GetItem&nbsp;list&nbsp;i&nbsp;val&nbsp;no_items;</span></span>
<span class="tr"><span class="th" id="line600">600</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line601">601</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line602">602</span><span class="td">&nbsp;if&nbsp;((i&lt;=0)&nbsp;||&nbsp;(i&gt;no_items))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line603">603</span><span class="td">&nbsp;&nbsp;print&nbsp;&quot;***&nbsp;Couldn&#39;t&nbsp;write&nbsp;to&nbsp;list&nbsp;entry&nbsp;&quot;,&nbsp;i,&nbsp;&quot;&nbsp;of&nbsp;a&nbsp;list&nbsp;which&quot;;</span></span>
<span class="tr"><span class="th" id="line604">604</span><span class="td">&nbsp;&nbsp;switch&nbsp;(no_items)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line605">605</span><span class="td">&nbsp;&nbsp;&nbsp;0:&nbsp;print&nbsp;&quot;&nbsp;is&nbsp;empty&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line606">606</span><span class="td">&nbsp;&nbsp;&nbsp;1:&nbsp;print&nbsp;&quot;&nbsp;has&nbsp;only&nbsp;one&nbsp;entry,&nbsp;numbered&nbsp;1&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line607">607</span><span class="td">&nbsp;&nbsp;&nbsp;default:&nbsp;print&nbsp;&quot;&nbsp;has&nbsp;entries&nbsp;numbered&nbsp;from&nbsp;1&nbsp;to&nbsp;&quot;,&nbsp;no_items,&nbsp;&quot;&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line608">608</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line609">609</span><span class="td">&nbsp;&nbsp;return&nbsp;RunTimeProblem(RTP_LISTRANGEERROR);</span></span>
<span class="tr"><span class="th" id="line610">610</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line611">611</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+i-1,&nbsp;val);</span></span>
<span class="tr"><span class="th" id="line612">612</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line613">613</span><span class="td"></span></span>
</div><div class='text'>
<h2>Put Item.</h2><p><p> Higher-level code should not use <span class="fixed">Write_LIST_OF_TY_GetItem</span>, because it does not properly keep track of block-value copying: the following should be used instead.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line620">620</span><span class="td">[&nbsp;LIST_OF_TY_PutItem&nbsp;list&nbsp;i&nbsp;v&nbsp;&nbsp;no_items&nbsp;nv;</span></span>
<span class="tr"><span class="th" id="line621">621</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line622">622</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line623">623</span><span class="td">&nbsp;if&nbsp;(KOVIsBlockValue(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F)))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line624">624</span><span class="td">&nbsp;&nbsp;nv&nbsp;=&nbsp;BlkValueCreate(BlkValueRead(list,&nbsp;LIST_ITEM_KOV_F));</span></span>
<span class="tr"><span class="th" id="line625">625</span><span class="td">&nbsp;&nbsp;BlkValueCopy(nv,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line626">626</span><span class="td">&nbsp;&nbsp;v&nbsp;=&nbsp;nv;</span></span>
<span class="tr"><span class="th" id="line627">627</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line628">628</span><span class="td">&nbsp;if&nbsp;((i&lt;=0)&nbsp;||&nbsp;(i&gt;no_items))&nbsp;return&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line629">629</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+i-1,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line630">630</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line631">631</span><span class="td"></span></span>
</div><div class='text'>
<h2>Multiple Object List.</h2><p><p> The parser uses one data structure which is really a list: but which can&#39;t be represented as such because the heap might not exist. This is the multiple object list, which is used to handle commands like TAKE ALL by firing off a sequence of actions with one of the objects taken from entries in turn of the list. The following converts it to a list structure.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line640">640</span><span class="td">[&nbsp;LIST_OF_TY_Mol&nbsp;list&nbsp;len&nbsp;i;</span></span>
<span class="tr"><span class="th" id="line641">641</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line642">642</span><span class="td">&nbsp;len&nbsp;=&nbsp;multiple_object--&gt;0;</span></span>
<span class="tr"><span class="th" id="line643">643</span><span class="td">&nbsp;LIST_OF_TY_SetLength(list,&nbsp;len);</span></span>
<span class="tr"><span class="th" id="line644">644</span><span class="td">&nbsp;for&nbsp;(i=1:&nbsp;i&lt;=len:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line645">645</span><span class="td">&nbsp;&nbsp;LIST_OF_TY_PutItem(list,&nbsp;i,&nbsp;multiple_object--&gt;i);</span></span>
<span class="tr"><span class="th" id="line646">646</span><span class="td">&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line647">647</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line648">648</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line649">649</span><span class="td">[&nbsp;LIST_OF_TY_Set_Mol&nbsp;list&nbsp;len&nbsp;i;</span></span>
<span class="tr"><span class="th" id="line650">650</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line651">651</span><span class="td">&nbsp;len&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line652">652</span><span class="td">&nbsp;if&nbsp;(len&nbsp;&gt;&nbsp;63)&nbsp;len&nbsp;=&nbsp;63;</span></span>
<span class="tr"><span class="th" id="line653">653</span><span class="td">&nbsp;multiple_object--&gt;0&nbsp;=&nbsp;len;</span></span>
<span class="tr"><span class="th" id="line654">654</span><span class="td">&nbsp;for&nbsp;(i=1:&nbsp;i&lt;=len:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line655">655</span><span class="td">&nbsp;&nbsp;multiple_object--&gt;i&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+i-1);</span></span>
<span class="tr"><span class="th" id="line656">656</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line657">657</span><span class="td"></span></span>
</div><div class='text'>
<h2>Reversing.</h2><p><p> Reversing a list is, happily, a very efficient operation when the list contains block-values: because the pointers are rearranged but none is duplicated or destroyed, we can for once ignore the fact that they are pointers to block-values and simply move them around like any other data.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line665">665</span><span class="td">[&nbsp;LIST_OF_TY_Reverse&nbsp;list&nbsp;no_items&nbsp;i&nbsp;v;</span></span>
<span class="tr"><span class="th" id="line666">666</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line667">667</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line668">668</span><span class="td">&nbsp;if&nbsp;(no_items&nbsp;&lt;&nbsp;2)&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line669">669</span><span class="td">&nbsp;for&nbsp;(i=0:i*2&lt;no_items:i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line670">670</span><span class="td">&nbsp;&nbsp;v&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+i);</span></span>
<span class="tr"><span class="th" id="line671">671</span><span class="td">&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+i,</span></span>
<span class="tr"><span class="th" id="line672">672</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+no_items-1-i));</span></span>
<span class="tr"><span class="th" id="line673">673</span><span class="td">&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+no_items-1-i,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line674">674</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line675">675</span><span class="td">&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line676">676</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line677">677</span><span class="td"></span></span>
</div><div class='text'>
<h2>Rotation.</h2><p><p> The same is true of rotation. Here, &quot;forwards&quot; rotation means towards the end of the list, &quot;backwards&quot; means towards the start.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line683">683</span><span class="td">[&nbsp;LIST_OF_TY_Rotate&nbsp;list&nbsp;backwards&nbsp;&nbsp;no_items&nbsp;i&nbsp;v;</span></span>
<span class="tr"><span class="th" id="line684">684</span><span class="td">&nbsp;if&nbsp;((list==0)&nbsp;||&nbsp;(BlkValueWeakKind(list)&nbsp;~=&nbsp;LIST_OF_TY))&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line685">685</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line686">686</span><span class="td">&nbsp;if&nbsp;(no_items&nbsp;&lt;&nbsp;2)&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line687">687</span><span class="td">&nbsp;if&nbsp;(backwards)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line688">688</span><span class="td">&nbsp;&nbsp;v&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE);</span></span>
<span class="tr"><span class="th" id="line689">689</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=0:i&lt;no_items-1:i++)</span></span>
<span class="tr"><span class="th" id="line690">690</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+i,</span></span>
<span class="tr"><span class="th" id="line691">691</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+i+1));</span></span>
<span class="tr"><span class="th" id="line692">692</span><span class="td">&nbsp;&nbsp;BlkValueWrite(list,&nbsp;no_items-1+LIST_ITEM_BASE,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line693">693</span><span class="td">&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line694">694</span><span class="td">&nbsp;&nbsp;v&nbsp;=&nbsp;BlkValueRead(list,&nbsp;no_items-1+LIST_ITEM_BASE);</span></span>
<span class="tr"><span class="th" id="line695">695</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=no_items-1:i&gt;0:i--)</span></span>
<span class="tr"><span class="th" id="line696">696</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+i,</span></span>
<span class="tr"><span class="th" id="line697">697</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+i-1));</span></span>
<span class="tr"><span class="th" id="line698">698</span><span class="td">&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line699">699</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line700">700</span><span class="td">&nbsp;return&nbsp;list;</span></span>
<span class="tr"><span class="th" id="line701">701</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line702">702</span><span class="td"></span></span>
</div><div class='text'>
<h2>Sorting.</h2><p><p> And the same, again, is true of sorting: but we do have to take note of block values when it comes to performing comparisons, because we can only compare items in the list by looking at their contents, not the pointers to their contents.<p></p><p> |LIST_OF_TY_Sort(list, dir, prop)| sorts the given <span class="fixed">list</span> in ascending order if <span class="fixed">dir</span> is 1, in descending order if <span class="fixed">dir</span> is $-1$, or in random order if <span class="fixed">dir</span> is 2. The comparison used is the one for the kind of value stored in the list, unless the optional argument <span class="fixed">prop</span> is supplied, in which case we sort based not on the item values but on their values for the property <span class="fixed">prop</span>. (This only makes sense if the list contains objects.)<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line717">717</span><span class="td">Global&nbsp;LIST_OF_TY_Sort_cf;</span></span>
<span class="tr"><span class="th" id="line718">718</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line719">719</span><span class="td">[&nbsp;LIST_OF_TY_Sort&nbsp;list&nbsp;dir&nbsp;prop&nbsp;cf&nbsp;&nbsp;i&nbsp;j&nbsp;no_items&nbsp;v;</span></span>
<span class="tr"><span class="th" id="line720">720</span><span class="td">&nbsp;BlkMakeMutable(list);</span></span>
<span class="tr"><span class="th" id="line721">721</span><span class="td">&nbsp;no_items&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_LENGTH_F);</span></span>
<span class="tr"><span class="th" id="line722">722</span><span class="td">&nbsp;if&nbsp;(dir&nbsp;==&nbsp;2)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line723">723</span><span class="td">&nbsp;&nbsp;if&nbsp;(no_items&nbsp;&lt;&nbsp;2)&nbsp;return;</span></span>
<span class="tr"><span class="th" id="line724">724</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=1:i&lt;no_items:i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line725">725</span><span class="td">&nbsp;&nbsp;&nbsp;j&nbsp;=&nbsp;random(i+1)&nbsp;-&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line726">726</span><span class="td">&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+i);</span></span>
<span class="tr"><span class="th" id="line727">727</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+i,&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+j));</span></span>
<span class="tr"><span class="th" id="line728">728</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+j,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line729">729</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line730">730</span><span class="td">&nbsp;&nbsp;return;</span></span>
<span class="tr"><span class="th" id="line731">731</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line732">732</span><span class="td">&nbsp;SetSortDomain(ListSwapEntries,&nbsp;ListCompareEntries);</span></span>
<span class="tr"><span class="th" id="line733">733</span><span class="td">&nbsp;if&nbsp;(cf)&nbsp;LIST_OF_TY_Sort_cf&nbsp;=&nbsp;BlkValueCompare;</span></span>
<span class="tr"><span class="th" id="line734">734</span><span class="td">&nbsp;else&nbsp;LIST_OF_TY_Sort_cf&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line735">735</span><span class="td">&nbsp;SortArray(list,&nbsp;prop,&nbsp;dir,&nbsp;no_items,&nbsp;false,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line736">736</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line737">737</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line738">738</span><span class="td">[&nbsp;ListSwapEntries&nbsp;list&nbsp;i&nbsp;j&nbsp;v;</span></span>
<span class="tr"><span class="th" id="line739">739</span><span class="td">&nbsp;if&nbsp;(i==j)&nbsp;return;</span></span>
<span class="tr"><span class="th" id="line740">740</span><span class="td">&nbsp;v&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+i-1);</span></span>
<span class="tr"><span class="th" id="line741">741</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+i-1,&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+j-1));</span></span>
<span class="tr"><span class="th" id="line742">742</span><span class="td">&nbsp;BlkValueWrite(list,&nbsp;LIST_ITEM_BASE+j-1,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line743">743</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line744">744</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line745">745</span><span class="td">[&nbsp;ListCompareEntries&nbsp;list&nbsp;col&nbsp;i&nbsp;j&nbsp;d&nbsp;cf;</span></span>
<span class="tr"><span class="th" id="line746">746</span><span class="td">&nbsp;if&nbsp;(i==j)&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line747">747</span><span class="td">&nbsp;i&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+i-1);</span></span>
<span class="tr"><span class="th" id="line748">748</span><span class="td">&nbsp;j&nbsp;=&nbsp;BlkValueRead(list,&nbsp;LIST_ITEM_BASE+j-1);</span></span>
<span class="tr"><span class="th" id="line749">749</span><span class="td">&nbsp;if&nbsp;(I7S_Col)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line750">750</span><span class="td">&nbsp;&nbsp;if&nbsp;(i&nbsp;provides&nbsp;I7S_Col)&nbsp;i=i.I7S_Col;&nbsp;else&nbsp;i=0;</span></span>
<span class="tr"><span class="th" id="line751">751</span><span class="td">&nbsp;&nbsp;if&nbsp;(j&nbsp;provides&nbsp;I7S_Col)&nbsp;j=j.I7S_Col;&nbsp;else&nbsp;j=0;</span></span>
<span class="tr"><span class="th" id="line752">752</span><span class="td">&nbsp;&nbsp;cf&nbsp;=&nbsp;LIST_OF_TY_Sort_cf;</span></span>
<span class="tr"><span class="th" id="line753">753</span><span class="td">&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line754">754</span><span class="td">&nbsp;&nbsp;cf&nbsp;=&nbsp;LIST_OF_TY_ComparisonFn(list);</span></span>
<span class="tr"><span class="th" id="line755">755</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line756">756</span><span class="td">&nbsp;if&nbsp;(cf&nbsp;==&nbsp;0)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line757">757</span><span class="td">&nbsp;&nbsp;if&nbsp;(i&nbsp;&gt;&nbsp;j)&nbsp;return&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line758">758</span><span class="td">&nbsp;&nbsp;if&nbsp;(i&nbsp;&lt;&nbsp;j)&nbsp;return&nbsp;-1;</span></span>
<span class="tr"><span class="th" id="line759">759</span><span class="td">&nbsp;&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line760">760</span><span class="td">&nbsp;}&nbsp;else</span></span>
<span class="tr"><span class="th" id="line761">761</span><span class="td">&nbsp;&nbsp;return&nbsp;cf(i,&nbsp;j);</span></span>
<span class="tr"><span class="th" id="line762">762</span><span class="td">];</span></span>
</div><footer><hr><p><em>From I6T lib 6/12N &copy; Graham Nelson and published under the <a href="https://github.com/zedlopez/standard_rules/blob/main/LICENSE.md">Artistic License 2.0</a>. Distributed with <a href="http://inform7.com/">Inform 7 6M62</a>.</em></p></footer></body></html>
