<!doctype html>
<html lang="en">
<meta charset="utf-8">
<head><title>BlockValues</title>
  <style>
span.th, span.td { display: table-cell; }
span.td { padding-left: 2rem; }
span.th { width:4rem; text-align: right; }
span.tr { display: table-row;     counter-increment: linenum; }
.pre-lines { font-family: monospace; margin-left: 3rem; line-height: 1.5rem; }
/*span.line_no::before {
    content: counter(linenum);
    text-align: right;
    display: block;
    font-family: monospace;
    font-weight: normal;
}*/
h1 { margin: 0; }
.fixed { font-family: monospace }
.em { font-style: italic; }
.center { text-align: center; }
    body { font-family: sans-serif; margin: 1.5rem 0 3rem 3rem; background-color: #fafaf0; width: 80rem; }
    .pre { font-family: monospace; margin: auto; width: 80rem; }
#front_matter,.text { width: 48rem; }
/* h3 { margin-top: 1.5rem; padding-top: 1.5rem; }*/
.text { border-bottom: .5px solid black; border-top: .5px solid black; margin-top: 1rem;
padding-bottom: .5rem; margin-bottom: 1.5rem; margin-top: 1.75rem; padding-top: .25rem;}
footer { margin-top: 3rem; padding-top: 1rem; border-top: .5px solid black; margin-bottom: 0;}
/*.subtitle { font-weight: bold; font-size: 1.2rem; }*/
.dstring { font-weight: bold;
  color: #095097; }
.sstring { font-weight: bold;
  color: #095097; }
.comment {  
  color: #156D15; } /* #207D20; */
    </style>
</head>
<body>
<header>
<h1>I6 Template Layer</h1>
<div class="subtitle"><a href="http://inform7.com/">Inform 7 6M62</a> &bull; <a href="./index.html">Index</a> &bull; <a href="./Introduction.i6t.html">Introduction</a> 
&bull; <a href="fn_index.html">Function Index</a> 
&bull; <a href="rules_index.html">Rules Index</a> 
</div><hr></header>
<div id="front_matter">
<h2><a href="./BlockValues.i6t.txt">BlockValues.i6t</a></h2><h3 id="#blockvalues-overview">Overview.</h3><p><p> Each I7 value is represented at run-time by an I6 word: on the Z-machine, a 16-bit number, and on Glulx, a 32-bit number. The correspondence between these numbers and the original values depends on the kind of value: &quot;number&quot; comes out as a signed twos-complement number, but &quot;time&quot; as an integer number of minutes since midnight, &quot;rulebook&quot; as the index of the rulebook in order of creation, and so on.<p></p><p> Even if a 32-bit number is available, this is not enough to represent the full range of values we might want: consider all the possible hundred-word essays of text, for instance. So for a whole range of kinds &ndash; &quot;text&quot;, &quot;list of K&quot;, &quot;stored action&quot; and so on &ndash; the I6 value at run-time is only a pointer to what is called a &quot;short block&quot;. This is typically only a few words long, and often only a single word: hence the term &quot;short&quot;. It has no header or other overhead, and its contents depend on the kind of value.<p></p><p> If we know that a given kind of value can be stored in, say, exactly 128 bits, then it&#39;s possible simply to store the whole thing in the short block. More often, though, the data needs to be flexible in size, or needs to be large. In that case, the short block will include (and sometimes, will consist only of) a pointer to data stored in a &quot;long block&quot;. Unlike the short block, the long block is a chunk of memory stored using the Flex system, and thus is genuinely a &quot;block&quot; in the sense of the Flex documentation.<p></p><p> It&#39;s possible to have several different short blocks each pointing to the same long block of underlying data: for example, the result of the I7 code<p></p><p> let L1 be { 2, 3, 5, 7, 11 }; let L2 be L1;<p></p><p> is to create L1 and L2 as pointers to two different short blocks, but the two SBs each point to the same long block, which contains the data for the list 2, 3, 5, 7, 11. Note that this makes it very fast to copy L1&#39;s contents into L2, because only L2&#39;s short block needs to change.<p></p><p> The rules for customers who want to deal with values like this are much like the rules for allocating memory with Flex. Calling <span class="fixed"><a href="./BlockValues.i6t.html#line540">BlkValueCreate</a></span> creates a new value, but this must always, and only once, later be disposed of using <span class="fixed"><a href="./BlockValues.i6t.html#line633">BlkValueFree</a></span>.<p></p><p> So if the short blocks of L1 and L2 both point to the same long block of actual data, what happens when only one of them is freed? The answer is that every long block has a reference count attached, which counts the number of short blocks pointing to it. In our example, this count is 2. If list L1 is freed, the long block&#39;s reference count is decremented to 1, but it remains in memory, and only L1&#39;s short block is given up; when list L2 is subsequently freed, both its short block and the now unwanted long block are given up.<p></p><p> The harder case to handle is what happens when L1 and L2 share a long block containing 2, 3, 5, 7, 11, but when the source text asks to &quot;add 13 to L1&quot;. If we simply changed the long block, that would affect L2 as well. So we must first make L1 &quot;mutable&quot;. This means copying the long block to make a new unique copy with reference count 1; assigning that to L1 in place of the original; and decrementing the reference count of the original from 2 to 1. L1 and L2 now point to two different long blocks, so it&#39;s safe to modify L1&#39;s.<p></p><p> Subtle and beautiful bugs can occur as a result of making a value mutable at the wrong moment. Beware in particular of reading data out of a long block, then writing it back again, because the act of writing may force the value owning the long block to become mutable; this will make a new copy of the data; but you will be left holding the old copy. Since these are functionally identical, you may not even notice, but calamities will occur later because the version of the value you&#39;re holding really belongs to somebody else and may be freed at any point.<p></p><p> Finally, note that the I7 compiler also creates block values representing constants. For example, the source text<p></p><p> let L1 be { 2, 3, 5, 7, 11 };<p></p><p> causes a block value representing this list to be stored in memory. The long block for a constant needs to be immortal, since this memory must never be freed: it&#39;s therefore given a reference count of &quot;infinity&quot;.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line86">86</span><span class="td">Constant RC_INFINITY = MAX_POSITIVE_NUMBER;</span></span>
</div><div class='text'>
<h3 id="#blockvalues-short-block-format">Short Block Format.</h3><p><p> A short block begins with a word which is usually, but not always, a pointer to the long block. There are three possibilities:<p></p><p> (a) 0 means the short block has length 1 and the long block begins at the very next word in memory. This makes it more convenient for I7 to compile BV constants, but isn&#39;t otherwise used.<p></p><p> (b) 1 to 255 means the short block has length 2 or more. The value is expected to be a bitmap in bits 4 to 8 together with a nonzero ID in bits 1 to 4. If the <span class="fixed"><a href="./BlockValues.i6t.html#line107">BLK_BVBITMAP_LONGBLOCK</a></span> bit is set, a pointer to the long block is stored in the second word of the short block.<p></p><p> (c) Otherwise the short block has length 1 and contains only a pointer to the long block.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line105">105</span><span class="td">Constant BLK_BVBITMAP           = $ff;</span></span>
<span class="tr"><span class="th" id="line106">106</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line107">107</span><span class="td">Constant BLK_BVBITMAP_LONGBLOCK = $10; <span class="comment">! Word 1 of SB is pointer to LB</span></span></span>
<span class="tr"><span class="th" id="line108">108</span><span class="td">Constant BLK_BVBITMAP_TEXT      = $20; <span class="comment">! BV holds a TEXT_TY value</span></span></span>
<span class="tr"><span class="th" id="line109">109</span><span class="td">Constant BLK_BVBITMAP_CONSTANT  = $40; <span class="comment">! BV holds a TEXT_TY value</span></span></span>
<span class="tr"><span class="th" id="line110">110</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line111">111</span><span class="td">#IFTRUE WORDSIZE == 4;</span></span>
<span class="tr"><span class="th" id="line112">112</span><span class="td">Constant BLK_BVBITMAP_LONGBLOCKMASK = $ffffff10;</span></span>
<span class="tr"><span class="th" id="line113">113</span><span class="td">Constant BLK_BVBITMAP_TEXTMASK      = $ffffff20;</span></span>
<span class="tr"><span class="th" id="line114">114</span><span class="td">Constant BLK_BVBITMAP_CONSTANTMASK  = $ffffff40;</span></span>
<span class="tr"><span class="th" id="line115">115</span><span class="td">#IFNOT;</span></span>
<span class="tr"><span class="th" id="line116">116</span><span class="td">Constant BLK_BVBITMAP_LONGBLOCKMASK = $ff10;</span></span>
<span class="tr"><span class="th" id="line117">117</span><span class="td">Constant BLK_BVBITMAP_TEXTMASK      = $ff20;</span></span>
<span class="tr"><span class="th" id="line118">118</span><span class="td">Constant BLK_BVBITMAP_CONSTANTMASK  = $ff40;</span></span>
<span class="tr"><span class="th" id="line119">119</span><span class="td">#ENDIF;</span></span>
</div><div class='text'>
<h3 id="#blockvalues-long-block-access">Long Block Access.</h3><p><p> Illustrating this:<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line125">125</span><span class="td">[ BlkValueGetLongBlock bv o;</span></span>
<span class="tr"><span class="th" id="line126">126</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (bv) {</span></span>
<span class="tr"><span class="th" id="line127">127</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o = bv--&gt;0;</span></span>
<span class="tr"><span class="th" id="line128">128</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (o == 0) return bv + WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line129">129</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (o &amp; BLK_BVBITMAP == o) {</span></span>
<span class="tr"><span class="th" id="line130">130</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (o &amp; BLK_BVBITMAP_LONGBLOCK) return bv--&gt;1;</span></span>
<span class="tr"><span class="th" id="line131">131</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;</span></span>
<span class="tr"><span class="th" id="line132">132</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line133">133</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return o;</span></span>
<span class="tr"><span class="th" id="line134">134</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line135">135</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return bv;</span></span>
<span class="tr"><span class="th" id="line136">136</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-weak-kind">Weak Kind.</h3><p><p> This returns the weak kind ID of a block value. Most of the time this information is stored in the long block, but that poses a problem for BVs which have no long block: we must use the bitmap instead.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line144">144</span><span class="td">[ BlkValueWeakKind bv o;</span></span>
<span class="tr"><span class="th" id="line145">145</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (bv) {</span></span>
<span class="tr"><span class="th" id="line146">146</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o = bv--&gt;0;</span></span>
<span class="tr"><span class="th" id="line147">147</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (o == 0) return bv--&gt;(BLK_HEADER_KOV+1);</span></span>
<span class="tr"><span class="th" id="line148">148</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (o &amp; BLK_BVBITMAP == o) {</span></span>
<span class="tr"><span class="th" id="line149">149</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (o &amp; BLK_BVBITMAP_TEXT) return TEXT_TY;</span></span>
<span class="tr"><span class="th" id="line150">150</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o = bv--&gt;1;</span></span>
<span class="tr"><span class="th" id="line151">151</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line152">152</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return o--&gt;BLK_HEADER_KOV;</span></span>
<span class="tr"><span class="th" id="line153">153</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line154">154</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return NIL_TY;</span></span>
<span class="tr"><span class="th" id="line155">155</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-reference-counting">Reference counting.</h3><p><p> Reference counts lie in a word at a fixed offset from the start of the long block: doctrinally, any block value with no long block at all (such as a piece of packed text) has reference count infinity.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line163">163</span><span class="td">[ BlkValueGetRefCountPrimitive bv long_block;</span></span>
<span class="tr"><span class="th" id="line164">164</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;long_block = BlkValueGetLongBlock(bv);</span></span>
<span class="tr"><span class="th" id="line165">165</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (long_block) return long_block--&gt;BLK_HEADER_RCOUNT;</span></span>
<span class="tr"><span class="th" id="line166">166</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return RC_INFINITY;</span></span>
<span class="tr"><span class="th" id="line167">167</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-changing-reference-counts">Changing Reference Counts.</h3><p><p> When incrementing, infinity&#39;s the limit; when decrementing, it never reduces. Note that the decrement function returns the new reference count, but the increment function returns nothing. It&#39;s only when reference counts go downwards that we have to worry about whether something happens.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line176">176</span><span class="td">[ BlkValueIncRefCountPrimitive bv long_block refc;</span></span>
<span class="tr"><span class="th" id="line177">177</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;long_block = BlkValueGetLongBlock(bv);</span></span>
<span class="tr"><span class="th" id="line178">178</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (long_block) {</span></span>
<span class="tr"><span class="th" id="line179">179</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refc = long_block--&gt;BLK_HEADER_RCOUNT;</span></span>
<span class="tr"><span class="th" id="line180">180</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (refc &lt; RC_INFINITY) long_block--&gt;BLK_HEADER_RCOUNT = refc + 1;</span></span>
<span class="tr"><span class="th" id="line181">181</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line182">182</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line183">183</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line184">184</span><span class="td">[ BlkValueDecRefCountPrimitive bv long_block refc;</span></span>
<span class="tr"><span class="th" id="line185">185</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;long_block = BlkValueGetLongBlock(bv);</span></span>
<span class="tr"><span class="th" id="line186">186</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (long_block) {</span></span>
<span class="tr"><span class="th" id="line187">187</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refc = long_block--&gt;BLK_HEADER_RCOUNT;</span></span>
<span class="tr"><span class="th" id="line188">188</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (refc &lt; RC_INFINITY) {</span></span>
<span class="tr"><span class="th" id="line189">189</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refc--;</span></span>
<span class="tr"><span class="th" id="line190">190</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (refc &lt; 0) BlkValueError(<span class="dstring">&quot;reference count negative&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line191">191</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long_block--&gt;BLK_HEADER_RCOUNT = refc;</span></span>
<span class="tr"><span class="th" id="line192">192</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line193">193</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return refc;</span></span>
<span class="tr"><span class="th" id="line194">194</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line195">195</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return RC_INFINITY;</span></span>
<span class="tr"><span class="th" id="line196">196</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-long-block-capacity">Long Block Capacity.</h3><p><p> As we&#39;ve seen, the long block has some metadata in a header, but otherwise it&#39;s organised as if it were an array, with entries 8, 16 or 32 bits wide. At any given time, the &quot;capacity&quot; of the LB is the number of entries in this array: that doesn&#39;t mean that the BV is using them all at any given moment.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line205">205</span><span class="td">[ BlkValueLBCapacity bv  long_block array_size_in_bytes entry_size_in_bytes flags;</span></span>
<span class="tr"><span class="th" id="line206">206</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;long_block = BlkValueGetLongBlock(bv);</span></span>
<span class="tr"><span class="th" id="line207">207</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (long_block == 0) return 0;</span></span>
<span class="tr"><span class="th" id="line208">208</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line209">209</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;array_size_in_bytes = FlexTotalSize(long_block);</span></span>
<span class="tr"><span class="th" id="line210">210</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line211">211</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;flags = long_block-&gt;BLK_HEADER_FLAGS;</span></span>
<span class="tr"><span class="th" id="line212">212</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;entry_size_in_bytes = 1;</span></span>
<span class="tr"><span class="th" id="line213">213</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_16_BIT) entry_size_in_bytes = 2;</span></span>
<span class="tr"><span class="th" id="line214">214</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else if (flags &amp; BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line215">215</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line216">216</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return array_size_in_bytes / entry_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line217">217</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line218">218</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line219">219</span><span class="td">[ BlkValueSetLBCapacity bv new_capacity  long_block flags entry_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line220">220</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (bv == 0) rfalse;</span></span>
<span class="tr"><span class="th" id="line221">221</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkMakeMutable(bv);</span></span>
<span class="tr"><span class="th" id="line222">222</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;long_block = BlkValueGetLongBlock(bv);</span></span>
<span class="tr"><span class="th" id="line223">223</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (long_block == 0) rfalse;</span></span>
<span class="tr"><span class="th" id="line224">224</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line225">225</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;flags = long_block-&gt;BLK_HEADER_FLAGS;</span></span>
<span class="tr"><span class="th" id="line226">226</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;entry_size_in_bytes = 1;</span></span>
<span class="tr"><span class="th" id="line227">227</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_16_BIT) entry_size_in_bytes = 2;</span></span>
<span class="tr"><span class="th" id="line228">228</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else if (flags &amp; BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line229">229</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line230">230</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;FlexResize(long_block, new_capacity*entry_size_in_bytes);</span></span>
<span class="tr"><span class="th" id="line231">231</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line232">232</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-long-block-array-access">Long Block Array Access.</h3><p><p> Though the customer thinks he&#39;s getting an array, in fact the storage in the LB is not necessarily contiguous, since it can span multiple Flex blocks. We abstract that with two routines to read and write entries.<p></p><p> <span class="fixed"><a href="./BlockValues.i6t.html#line250">BlkValueRead</a></span> takes two compulsory arguments and one optional one. Thus:<p></p><p><div class="pre-lines">BlkValueRead(bv, n)</div><p></p><p> reads the nth entry in the long block for <span class="fixed">bv</span>, whereas<p></p><p><div class="pre-lines">BlkValueRead(long_block, n, true)</div><p></p><p> read it from the given long block directly. <span class="fixed"><a href="./BlockValues.i6t.html#line284">BlkValueWrite</a></span> is similar.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line250">250</span><span class="td">[ BlkValueRead from pos do_not_indirect</span></span>
<span class="tr"><span class="th" id="line251">251</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;</span></span>
<span class="tr"><span class="th" id="line252">252</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (from == 0) rfalse;</span></span>
<span class="tr"><span class="th" id="line253">253</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (do_not_indirect)</span></span>
<span class="tr"><span class="th" id="line254">254</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long_block = from;</span></span>
<span class="tr"><span class="th" id="line255">255</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else</span></span>
<span class="tr"><span class="th" id="line256">256</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long_block = BlkValueGetLongBlock(from);</span></span>
<span class="tr"><span class="th" id="line257">257</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line258">258</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;flags = long_block-&gt;BLK_HEADER_FLAGS;</span></span>
<span class="tr"><span class="th" id="line259">259</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;entry_size_in_bytes = 1;</span></span>
<span class="tr"><span class="th" id="line260">260</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_16_BIT) entry_size_in_bytes = 2;</span></span>
<span class="tr"><span class="th" id="line261">261</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else if (flags &amp; BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line262">262</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line263">263</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;</span></span>
<span class="tr"><span class="th" id="line264">264</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else header_size_in_bytes = BLK_DATA_OFFSET;</span></span>
<span class="tr"><span class="th" id="line265">265</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line266">266</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;seek_byte_position = pos*entry_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line267">267</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;for (: long_block~=NULL: long_block=long_block--&gt;BLK_NEXT) {</span></span>
<span class="tr"><span class="th" id="line268">268</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line269">269</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((seek_byte_position &gt;= 0) &amp;&amp; (seek_byte_position&lt;chunk_size_in_bytes)) {</span></span>
<span class="tr"><span class="th" id="line270">270</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long_block = long_block + header_size_in_bytes + seek_byte_position;</span></span>
<span class="tr"><span class="th" id="line271">271</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(entry_size_in_bytes) {</span></span>
<span class="tr"><span class="th" id="line272">272</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1: return long_block-&gt;0;</span></span>
<span class="tr"><span class="th" id="line273">273</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:    #Iftrue (WORDSIZE == 2); return long_block--&gt;0;</span></span>
<span class="tr"><span class="th" id="line274">274</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifnot; return (long_block-&gt;0)*256 + (long_block-&gt;1);</span></span>
<span class="tr"><span class="th" id="line275">275</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif;</span></span>
<span class="tr"><span class="th" id="line276">276</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4: return long_block--&gt;0;</span></span>
<span class="tr"><span class="th" id="line277">277</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line278">278</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line279">279</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seek_byte_position = seek_byte_position - chunk_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line280">280</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line281">281</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;<span class="dstring">&quot;*** BlkValueRead: reading from index out of range: &quot;</span>, pos, <span class="dstring">&quot; in &quot;</span>, from, <span class="dstring">&quot; ***&quot;</span>;</span></span>
<span class="tr"><span class="th" id="line282">282</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line283">283</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line284">284</span><span class="td">[ BlkValueWrite to pos val do_not_indirect</span></span>
<span class="tr"><span class="th" id="line285">285</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes seek_byte_position;</span></span>
<span class="tr"><span class="th" id="line286">286</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (to == 0) rfalse;</span></span>
<span class="tr"><span class="th" id="line287">287</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (do_not_indirect)</span></span>
<span class="tr"><span class="th" id="line288">288</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long_block = to;</span></span>
<span class="tr"><span class="th" id="line289">289</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else {</span></span>
<span class="tr"><span class="th" id="line290">290</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkMakeMutable(to);</span></span>
<span class="tr"><span class="th" id="line291">291</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long_block = BlkValueGetLongBlock(to);</span></span>
<span class="tr"><span class="th" id="line292">292</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line293">293</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line294">294</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;flags = long_block-&gt;BLK_HEADER_FLAGS;</span></span>
<span class="tr"><span class="th" id="line295">295</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;entry_size_in_bytes = 1;</span></span>
<span class="tr"><span class="th" id="line296">296</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_16_BIT) entry_size_in_bytes = 2;</span></span>
<span class="tr"><span class="th" id="line297">297</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else if (flags &amp; BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line298">298</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line299">299</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;</span></span>
<span class="tr"><span class="th" id="line300">300</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else header_size_in_bytes = BLK_DATA_OFFSET;</span></span>
<span class="tr"><span class="th" id="line301">301</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line302">302</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;seek_byte_position = pos*entry_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line303">303</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;for (:long_block~=NULL:long_block=long_block--&gt;BLK_NEXT) {</span></span>
<span class="tr"><span class="th" id="line304">304</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line305">305</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((seek_byte_position &gt;= 0) &amp;&amp; (seek_byte_position&lt;chunk_size_in_bytes)) {</span></span>
<span class="tr"><span class="th" id="line306">306</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long_block = long_block + header_size_in_bytes + seek_byte_position;</span></span>
<span class="tr"><span class="th" id="line307">307</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(entry_size_in_bytes) {</span></span>
<span class="tr"><span class="th" id="line308">308</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1: long_block-&gt;0 = val;</span></span>
<span class="tr"><span class="th" id="line309">309</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:    #Iftrue (WORDSIZE == 2); long_block--&gt;0 = val;</span></span>
<span class="tr"><span class="th" id="line310">310</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifnot; long_block-&gt;0 = (val/256)%256; long_block-&gt;1 = val%256;</span></span>
<span class="tr"><span class="th" id="line311">311</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif;</span></span>
<span class="tr"><span class="th" id="line312">312</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4: long_block--&gt;0 = val;</span></span>
<span class="tr"><span class="th" id="line313">313</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line314">314</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span></span>
<span class="tr"><span class="th" id="line315">315</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line316">316</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;seek_byte_position = seek_byte_position - chunk_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line317">317</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line318">318</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;<span class="dstring">&quot;*** BlkValueWrite: writing to index out of range: &quot;</span>, pos, <span class="dstring">&quot; in &quot;</span>, to, <span class="dstring">&quot; ***&quot;</span>;</span></span>
<span class="tr"><span class="th" id="line319">319</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-first-zero-entry">First Zero Entry.</h3><p><p> This returns the entry index of the first zero entry in the long block&#39;s array, or -1 if it has no zeros.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line326">326</span><span class="td">[ BlkValueSeekZeroEntry from</span></span>
<span class="tr"><span class="th" id="line327">327</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;long_block chunk_size_in_bytes header_size_in_bytes flags entry_size_in_bytes</span></span>
<span class="tr"><span class="th" id="line328">328</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;byte_position addr from_addr to_addr;</span></span>
<span class="tr"><span class="th" id="line329">329</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (from == 0) return -1;</span></span>
<span class="tr"><span class="th" id="line330">330</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;long_block = BlkValueGetLongBlock(from);</span></span>
<span class="tr"><span class="th" id="line331">331</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line332">332</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;flags = long_block-&gt;BLK_HEADER_FLAGS;</span></span>
<span class="tr"><span class="th" id="line333">333</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;entry_size_in_bytes = 1;</span></span>
<span class="tr"><span class="th" id="line334">334</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_16_BIT) entry_size_in_bytes = 2;</span></span>
<span class="tr"><span class="th" id="line335">335</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else if (flags &amp; BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line336">336</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line337">337</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_MULTIPLE) header_size_in_bytes = BLK_DATA_MULTI_OFFSET;</span></span>
<span class="tr"><span class="th" id="line338">338</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else header_size_in_bytes = BLK_DATA_OFFSET;</span></span>
<span class="tr"><span class="th" id="line339">339</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line340">340</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;byte_position = 0;</span></span>
<span class="tr"><span class="th" id="line341">341</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;for (: long_block~=NULL: long_block=long_block--&gt;BLK_NEXT) {</span></span>
<span class="tr"><span class="th" id="line342">342</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunk_size_in_bytes = FlexSize(long_block) - header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line343">343</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from_addr = long_block + header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line344">344</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_addr = from_addr + chunk_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line345">345</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(entry_size_in_bytes) {</span></span>
<span class="tr"><span class="th" id="line346">346</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:</span></span>
<span class="tr"><span class="th" id="line347">347</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (addr = from_addr: addr &lt; to_addr: addr++)</span></span>
<span class="tr"><span class="th" id="line348">348</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (addr-&gt;0 == 0)</span></span>
<span class="tr"><span class="th" id="line349">349</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return byte_position + addr - from_addr;</span></span>
<span class="tr"><span class="th" id="line350">350</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:</span></span>
<span class="tr"><span class="th" id="line351">351</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#iftrue (WORDSIZE == 2);</span></span>
<span class="tr"><span class="th" id="line352">352</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (addr = from_addr: addr &lt; to_addr: addr=addr+2)</span></span>
<span class="tr"><span class="th" id="line353">353</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (addr--&gt;0 == 0)</span></span>
<span class="tr"><span class="th" id="line354">354</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (byte_position + addr - from_addr)/2;</span></span>
<span class="tr"><span class="th" id="line355">355</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifnot;</span></span>
<span class="tr"><span class="th" id="line356">356</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (addr = from_addr: addr &lt; to_addr: addr=addr+2)</span></span>
<span class="tr"><span class="th" id="line357">357</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ((addr-&gt;0 == 0) &amp;&amp; (addr-&gt;1 == 0))</span></span>
<span class="tr"><span class="th" id="line358">358</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (byte_position + addr - from_addr)/2;</span></span>
<span class="tr"><span class="th" id="line359">359</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif;</span></span>
<span class="tr"><span class="th" id="line360">360</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:</span></span>
<span class="tr"><span class="th" id="line361">361</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (addr = from_addr: addr &lt; to_addr: addr=addr+4)</span></span>
<span class="tr"><span class="th" id="line362">362</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (addr--&gt;0 == 0)</span></span>
<span class="tr"><span class="th" id="line363">363</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (byte_position + addr - from_addr)/4;</span></span>
<span class="tr"><span class="th" id="line364">364</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line365">365</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte_position = byte_position + chunk_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line366">366</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line367">367</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return -1;</span></span>
<span class="tr"><span class="th" id="line368">368</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-mass-copy-entries">Mass Copy Entries.</h3><p><p> This copies a given number of entries from one BV&#39;s long block to another; they must both be of the same word size but can differ in header size. Functionally, it&#39;s identical to<p></p><p><div class="pre-lines">for (n=0: n&lt;no_entries_to_copy: n++)</div><div class="pre-lines"> BlkValueWrite(to_bv, n, BlkValueRead(from_bv, n));</div><p></p><p> but it&#39;s much, much faster, and runs in a reasonably small number of cycles given what it needs to do.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line382">382</span><span class="td">[ BlkValueMassCopyEntries to_bv from_bv no_entries_to_copy</span></span>
<span class="tr"><span class="th" id="line383">383</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;from_long_block from_addr from_bytes_left from_header_size_in_bytes</span></span>
<span class="tr"><span class="th" id="line384">384</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_long_block to_addr to_bytes_left to_header_size_in_bytes</span></span>
<span class="tr"><span class="th" id="line385">385</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;bytes_to_copy flags entry_size_in_bytes min;</span></span>
<span class="tr"><span class="th" id="line386">386</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line387">387</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkMakeMutable(to_bv);</span></span>
<span class="tr"><span class="th" id="line388">388</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line389">389</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;from_long_block = BlkValueGetLongBlock(from_bv);</span></span>
<span class="tr"><span class="th" id="line390">390</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_long_block = BlkValueGetLongBlock(to_bv);</span></span>
<span class="tr"><span class="th" id="line391">391</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line392">392</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;flags = from_long_block-&gt;BLK_HEADER_FLAGS;</span></span>
<span class="tr"><span class="th" id="line393">393</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;entry_size_in_bytes = 1;</span></span>
<span class="tr"><span class="th" id="line394">394</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_16_BIT) entry_size_in_bytes = 2;</span></span>
<span class="tr"><span class="th" id="line395">395</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else if (flags &amp; BLK_FLAG_WORD) entry_size_in_bytes = WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line396">396</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line397">397</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if ((flags &amp; (BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)) &amp;&amp;</span></span>
<span class="tr"><span class="th" id="line398">398</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == false))</span></span>
<span class="tr"><span class="th" id="line399">399</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueError(<span class="dstring">&quot;copy resizing failed&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line400">400</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line401">401</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_MULTIPLE) from_header_size_in_bytes = BLK_DATA_MULTI_OFFSET;</span></span>
<span class="tr"><span class="th" id="line402">402</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else from_header_size_in_bytes = BLK_DATA_OFFSET;</span></span>
<span class="tr"><span class="th" id="line403">403</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;flags = to_long_block-&gt;BLK_HEADER_FLAGS;</span></span>
<span class="tr"><span class="th" id="line404">404</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_MULTIPLE) to_header_size_in_bytes = BLK_DATA_MULTI_OFFSET;</span></span>
<span class="tr"><span class="th" id="line405">405</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else to_header_size_in_bytes = BLK_DATA_OFFSET;</span></span>
<span class="tr"><span class="th" id="line406">406</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line407">407</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;from_addr = from_long_block + from_header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line408">408</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;from_bytes_left = FlexSize(from_long_block) - from_header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line409">409</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_addr = to_long_block + to_header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line410">410</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_bytes_left = FlexSize(to_long_block) - to_header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line411">411</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line412">412</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;bytes_to_copy = entry_size_in_bytes*no_entries_to_copy;</span></span>
<span class="tr"><span class="th" id="line413">413</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;while (true) {</span></span>
<span class="tr"><span class="th" id="line414">414</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (from_bytes_left == 0) {</span></span>
<span class="tr"><span class="th" id="line415">415</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from_long_block = from_long_block--&gt;BLK_NEXT;</span></span>
<span class="tr"><span class="th" id="line416">416</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (from_long_block == 0) BlkValueError(<span class="dstring">&quot;copy destination exhausted&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line417">417</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from_addr = from_long_block + from_header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line418">418</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from_bytes_left = FlexSize(from_long_block) - from_header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line419">419</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (to_bytes_left == 0) {</span></span>
<span class="tr"><span class="th" id="line420">420</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_long_block = to_long_block--&gt;BLK_NEXT;</span></span>
<span class="tr"><span class="th" id="line421">421</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (to_long_block == 0) BlkValueError(<span class="dstring">&quot;copy source exhausted&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line422">422</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_addr = to_long_block + to_header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line423">423</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_bytes_left = FlexSize(to_long_block) - to_header_size_in_bytes;</span></span>
<span class="tr"><span class="th" id="line424">424</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {</span></span>
<span class="tr"><span class="th" id="line425">425</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min = from_bytes_left; if (to_bytes_left &lt; min) min = to_bytes_left;</span></span>
<span class="tr"><span class="th" id="line426">426</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bytes_to_copy &lt;= min) {</span></span>
<span class="tr"><span class="th" id="line427">427</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcpy(to_addr, from_addr, bytes_to_copy);</span></span>
<span class="tr"><span class="th" id="line428">428</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span></span>
<span class="tr"><span class="th" id="line429">429</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line430">430</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Memcpy(to_addr, from_addr, min);</span></span>
<span class="tr"><span class="th" id="line431">431</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes_to_copy = bytes_to_copy - min;</span></span>
<span class="tr"><span class="th" id="line432">432</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from_addr = from_addr + min;</span></span>
<span class="tr"><span class="th" id="line433">433</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from_bytes_left = from_bytes_left - min;</span></span>
<span class="tr"><span class="th" id="line434">434</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_addr = to_addr + min;</span></span>
<span class="tr"><span class="th" id="line435">435</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_bytes_left = to_bytes_left - min;</span></span>
<span class="tr"><span class="th" id="line436">436</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line437">437</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line438">438</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-mass-copy-from-array">Mass Copy From Array.</h3><p><p> The following is helpful when reading an array of characters into a text:<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line444">444</span><span class="td">[ BlkValueMassCopyFromArray to_bv from_array from_entry_size no_entries_to_copy</span></span>
<span class="tr"><span class="th" id="line445">445</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_long_block to_addr to_entries_left to_header_size to_entry_size</span></span>
<span class="tr"><span class="th" id="line446">446</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;flags;</span></span>
<span class="tr"><span class="th" id="line447">447</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line448">448</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkMakeMutable(to_bv);</span></span>
<span class="tr"><span class="th" id="line449">449</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line450">450</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_long_block = BlkValueGetLongBlock(to_bv);</span></span>
<span class="tr"><span class="th" id="line451">451</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line452">452</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;flags = to_long_block-&gt;BLK_HEADER_FLAGS;</span></span>
<span class="tr"><span class="th" id="line453">453</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_entry_size = 1;</span></span>
<span class="tr"><span class="th" id="line454">454</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_16_BIT) to_entry_size = 2;</span></span>
<span class="tr"><span class="th" id="line455">455</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else if (flags &amp; BLK_FLAG_WORD) to_entry_size = WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line456">456</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line457">457</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if ((flags &amp; (BLK_FLAG_MULTIPLE + BLK_FLAG_TRUNCMULT)) &amp;&amp;</span></span>
<span class="tr"><span class="th" id="line458">458</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(BlkValueSetLBCapacity(to_bv, no_entries_to_copy) == false))</span></span>
<span class="tr"><span class="th" id="line459">459</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueError(<span class="dstring">&quot;copy resizing failed&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line460">460</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line461">461</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flags &amp; BLK_FLAG_MULTIPLE) to_header_size = BLK_DATA_MULTI_OFFSET;</span></span>
<span class="tr"><span class="th" id="line462">462</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else to_header_size = BLK_DATA_OFFSET;</span></span>
<span class="tr"><span class="th" id="line463">463</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line464">464</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_addr = to_long_block + to_header_size;</span></span>
<span class="tr"><span class="th" id="line465">465</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_entries_left = (FlexSize(to_long_block) - to_header_size)/to_entry_size;</span></span>
<span class="tr"><span class="th" id="line466">466</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line467">467</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;while (no_entries_to_copy &gt; to_entries_left) {</span></span>
<span class="tr"><span class="th" id="line468">468</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, to_entries_left);</span></span>
<span class="tr"><span class="th" id="line469">469</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;no_entries_to_copy = no_entries_to_copy - to_entries_left;</span></span>
<span class="tr"><span class="th" id="line470">470</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from_array = from_array + to_entries_left*from_entry_size;</span></span>
<span class="tr"><span class="th" id="line471">471</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_long_block = to_long_block--&gt;BLK_NEXT;</span></span>
<span class="tr"><span class="th" id="line472">472</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (to_long_block == 0) BlkValueError(<span class="dstring">&quot;copy source exhausted&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line473">473</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_addr = to_long_block + to_header_size;</span></span>
<span class="tr"><span class="th" id="line474">474</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to_entries_left = (FlexSize(to_long_block) - to_header_size)/to_entry_size;</span></span>
<span class="tr"><span class="th" id="line475">475</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line476">476</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (no_entries_to_copy &gt; 0) {</span></span>
<span class="tr"><span class="th" id="line477">477</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrcpy(to_addr, to_entry_size, from_array, from_entry_size, no_entries_to_copy);</span></span>
<span class="tr"><span class="th" id="line478">478</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line479">479</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-kovs-routines">KOVS Routines.</h3><p><p> Different kinds of value use different data formats for both their short and long blocks, so it follows that each kind needs its own routines to carry out the fundamental operations of creating, destroying, copying and comparing. This is organised at run-time by giving each kind of block value a &quot;KOVS&quot;, a &quot;kind of value support&quot; routine. These are named systematically by suffixing <span class="fixed">_Support</span>: that is, the support function for <span class="fixed">TEXT_TY</span> is called <span class="fixed"><a href="./Text.i6t.html#line82">TEXT_TY_Support</a></span> and so on.<p></p><p> I7 automatically compiles a function called <span class="fixed">KOVSupportFunction</span> which returns the KOVS for a given kind. Note that this depends only on the weak kind, not the strong one: so &quot;list of numbers&quot; and &quot;list of texts&quot;, for example, share a common KOVS which handles all list support.<p></p><p> The support function can be called with any of the following task constants as its first argument: it then has a further one to three arguments depending on the task in hand.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line500">500</span><span class="td">Constant CREATE_KOVS      = 1;</span></span>
<span class="tr"><span class="th" id="line501">501</span><span class="td">Constant CAST_KOVS        = 2;</span></span>
<span class="tr"><span class="th" id="line502">502</span><span class="td">Constant DESTROY_KOVS     = 3;</span></span>
<span class="tr"><span class="th" id="line503">503</span><span class="td">Constant MAKEMUTABLE_KOVS = 4;</span></span>
<span class="tr"><span class="th" id="line504">504</span><span class="td">Constant COPYKIND_KOVS    = 5;</span></span>
<span class="tr"><span class="th" id="line505">505</span><span class="td">Constant EXTENT_KOVS      = 6;</span></span>
<span class="tr"><span class="th" id="line506">506</span><span class="td">Constant COPYQUICK_KOVS   = 7;</span></span>
<span class="tr"><span class="th" id="line507">507</span><span class="td">Constant COPYSB_KOVS      = 8;</span></span>
<span class="tr"><span class="th" id="line508">508</span><span class="td">Constant KINDDATA_KOVS    = 9;</span></span>
<span class="tr"><span class="th" id="line509">509</span><span class="td">Constant COPY_KOVS        = 10;</span></span>
<span class="tr"><span class="th" id="line510">510</span><span class="td">Constant COMPARE_KOVS     = 11;</span></span>
<span class="tr"><span class="th" id="line511">511</span><span class="td">Constant READ_FILE_KOVS   = 12;</span></span>
<span class="tr"><span class="th" id="line512">512</span><span class="td">Constant WRITE_FILE_KOVS  = 13;</span></span>
<span class="tr"><span class="th" id="line513">513</span><span class="td">Constant HASH_KOVS        = 14;</span></span>
<span class="tr"><span class="th" id="line514">514</span><span class="td">Constant DEBUG_KOVS       = 15;</span></span>
<span class="tr"><span class="th" id="line515">515</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line516">516</span><span class="td"><span class="comment">! Constant BLKVALUE_TRACE; ! Uncomment this to expose masses of tracery</span></span></span>
</div><div class='text'>
<h3 id="#blockvalues-creation">Creation.</h3><p><p> To create a block value, call:<p></p><p><div class="pre-lines">BlkValueCreate(kind)</div><p></p><p> where <span class="fixed">K</span> is its (strong) kind ID. Optionally, call:<p></p><p><div class="pre-lines">BlkValueCreate(K, short_block)</div><p></p><p> to mandate that the short block needs to be located at the given address outside the heap: but don&#39;t do this unless you can guarantee that space of the necessary length will be available there for as long as the lifetime of the value; and please note, it really does matter that this address lies outside the heap, for reasons to be seen below.<p></p><p> These work by delegating to:<p></p><p><div class="pre-lines">kovs(CREATE_KOVS, strong_kind, short_block)</div><p></p><p> which returns the address of the short block for the new value.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line540">540</span><span class="td">[ BlkValueCreate strong_kind short_block  kovs;</span></span>
<span class="tr"><span class="th" id="line541">541</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line542">542</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs = KOVSupportFunction(strong_kind, <span class="dstring">&quot;impossible allocation&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line543">543</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;short_block = kovs(CREATE_KOVS, strong_kind, short_block);</span></span>
<span class="tr"><span class="th" id="line544">544</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line545">545</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;#ifdef BLKVALUE_TRACE; print <span class="dstring">&quot;Created: &quot;</span>, (BlkValueDebug) short_block, <span class="dstring">&quot;^&quot;</span>; #endif;</span></span>
<span class="tr"><span class="th" id="line546">546</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line547">547</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">! The new value is represented in I6 as the pointer to its short block:</span></span></span>
<span class="tr"><span class="th" id="line548">548</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return short_block;</span></span>
<span class="tr"><span class="th" id="line549">549</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-errors">Errors.</h3><p><p> No I7 source text should ever result in a call to this, unless it does unpleasant things at the I6 level.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line556">556</span><span class="td">[ BlkValueError reason;</span></span>
<span class="tr"><span class="th" id="line557">557</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;print <span class="dstring">&quot;*** Value handling failed: &quot;</span>, (string) reason, <span class="dstring">&quot; ***^&quot;</span>;</span></span>
<span class="tr"><span class="th" id="line558">558</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;RunTimeProblem(RTP_HEAPERROR);</span></span>
<span class="tr"><span class="th" id="line559">559</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;@quit;</span></span>
<span class="tr"><span class="th" id="line560">560</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-short-block-allocation">Short Block Allocation.</h3><p><p> The first thing a KOVS does when creating a value is to initialise its short block. The following routines provide for a one-word and a two-word short block respectively. The KOVS should pass these routines the same <span class="fixed">short_block</span> value it was called with. As can be seen, if this is zero then we need to conjure up memory from somewhere: we do this using Flex. That incurs a fair amount of overhead in time and memory, though. The SB data is stored in the data portion of the Flex block, which is why we get its address from by adding the data offset to the block address.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line573">573</span><span class="td">[ BlkValueCreateSB1 short_block val;</span></span>
<span class="tr"><span class="th" id="line574">574</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (short_block == 0)</span></span>
<span class="tr"><span class="th" id="line575">575</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short_block = FlexAllocate(WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET;</span></span>
<span class="tr"><span class="th" id="line576">576</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;short_block--&gt;0 = val;</span></span>
<span class="tr"><span class="th" id="line577">577</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return short_block;</span></span>
<span class="tr"><span class="th" id="line578">578</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line579">579</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line580">580</span><span class="td">[ BlkValueCreateSB2 short_block val1 val2;</span></span>
<span class="tr"><span class="th" id="line581">581</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (short_block == 0)</span></span>
<span class="tr"><span class="th" id="line582">582</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short_block = FlexAllocate(2*WORDSIZE, 0, BLK_FLAG_WORD) + BLK_DATA_OFFSET;</span></span>
<span class="tr"><span class="th" id="line583">583</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;short_block--&gt;0 = val1; short_block--&gt;1 = val2;</span></span>
<span class="tr"><span class="th" id="line584">584</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return short_block;</span></span>
<span class="tr"><span class="th" id="line585">585</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-block-values-on-stack">Block Values On Stack.</h3><p><p> As noted above, it&#39;s wasteful to keep allocating short blocks using Flex. For the short blocks of block values in local variables, we store them on a stack instead. This is a top-down stack, so the current stack frame starts out just after the end of the stack area in memory (and therefore points to an empty stack frame); it drops down as new frames are created.<p></p><p> <span class="fixed"><a href="./BlockValues.i6t.html#line610">BlkValueCreateOnStack</a></span> acts exactly like <span class="fixed"><a href="./BlockValues.i6t.html#line540">BlkValueCreate</a></span>, but stores the short block at the given word offset in the current stack frame. (I7 compiles calls to these routines when compiling code to manage local variables.)<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line600">600</span><span class="td">[ StackFramingInitialise;</span></span>
<span class="tr"><span class="th" id="line601">601</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;I7SFRAME = blockv_stack + WORDSIZE*BLOCKV_STACK_SIZE;</span></span>
<span class="tr"><span class="th" id="line602">602</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line603">603</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line604">604</span><span class="td">[ StackFrameCreate size new;</span></span>
<span class="tr"><span class="th" id="line605">605</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;new = I7SFRAME - WORDSIZE*size;</span></span>
<span class="tr"><span class="th" id="line606">606</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (new &lt; blockv_stack) { RunTimeProblem(RTP_HEAPERROR); @quit; }</span></span>
<span class="tr"><span class="th" id="line607">607</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;I7SFRAME = new;</span></span>
<span class="tr"><span class="th" id="line608">608</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line609">609</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line610">610</span><span class="td">[ BlkValueCreateOnStack offset strong_kind;</span></span>
<span class="tr"><span class="th" id="line611">611</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueCreate(strong_kind, I7SFRAME + WORDSIZE*offset);</span></span>
<span class="tr"><span class="th" id="line612">612</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line613">613</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line614">614</span><span class="td">[ BlkValueFreeOnStack offset;</span></span>
<span class="tr"><span class="th" id="line615">615</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueFree(I7SFRAME + WORDSIZE*offset);</span></span>
<span class="tr"><span class="th" id="line616">616</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-freeing">Freeing.</h3><p><p> As noted above, every value returned by <span class="fixed"><a href="./BlockValues.i6t.html#line540">BlkValueCreate</a></span> must later be freed by calling the following routine exactly once:<p></p><p><div class="pre-lines">BlkValueFree(value)</div><p></p><p> In particular, if a block value is stored in any I6 location which is about to be overwritten with a new value, it&#39;s essential to call this in order properly to dispose of the old value.<p></p><p> As noted above, short blocks are sometimes created within Flex blocks on the heap, using <span class="fixed"><a href="./Flex.i6t.html#line297">FlexAllocate</a></span>; and if this is one of those, we need to free the relevant Flex block.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line633">633</span><span class="td">[ BlkValueFree bv kovs d;</span></span>
<span class="tr"><span class="th" id="line634">634</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (bv == 0) return;</span></span>
<span class="tr"><span class="th" id="line635">635</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line636">636</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">! Dispose of any data in the long block</span></span></span>
<span class="tr"><span class="th" id="line637">637</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs = KOVSupportFunction(BlkValueWeakKind(bv), <span class="dstring">&quot;impossible deallocation&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line638">638</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueDestroyPrimitive(bv, kovs);</span></span>
<span class="tr"><span class="th" id="line639">639</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line640">640</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">! Free any heap memory occupied by the short block</span></span></span>
<span class="tr"><span class="th" id="line641">641</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;d = bv - Flex_Heap;</span></span>
<span class="tr"><span class="th" id="line642">642</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if ((d &gt;= 0) &amp;&amp; (d &lt; MEMORY_HEAP_SIZE + 16))</span></span>
<span class="tr"><span class="th" id="line643">643</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FlexFree(bv - BLK_DATA_OFFSET);</span></span>
<span class="tr"><span class="th" id="line644">644</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-quick-copy">Quick Copy.</h3><p><p> The basic method of copying block value B into block value A is to destroy the old contents of A, which are about to be overwritten; then copy the short block of A into the short block of B, a quick process; and increment the reference count of B.<p></p><p> The support function should respond to:<p></p><p><div class="pre-lines">kovs(COPYSB_KOVS, to_bv, from_bv)</div><p></p><p> by copying the short blocks alone.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line659">659</span><span class="td">[ BlkValueQuickCopyPrimitive to_bv from_bv kovs;</span></span>
<span class="tr"><span class="th" id="line660">660</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueDestroyPrimitive(to_bv, kovs);</span></span>
<span class="tr"><span class="th" id="line661">661</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs(COPYSB_KOVS, to_bv, from_bv);</span></span>
<span class="tr"><span class="th" id="line662">662</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueIncRefCountPrimitive(from_bv);</span></span>
<span class="tr"><span class="th" id="line663">663</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-short-block-copy">Short Block Copy.</h3><p><p> In fact, most of the work of copying a short block is standard. If a SB consists only a single word pointing to the LB, the first routine below handles all the work needed to handle the <span class="fixed"><a href="./BlockValues.i6t.html#line507">COPYSB_KOVS</a></span> task. The surprising line in this routine is to deal with the convention that a pointer value of 0 means the LB immediately follows the SB: if that&#39;s true in <span class="fixed">from_bv</span>, it won&#39;t be true in <span class="fixed">to_bv</span>, so we must correct it.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line674">674</span><span class="td">[ BlkValueCopySB1 to_bv from_bv;</span></span>
<span class="tr"><span class="th" id="line675">675</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_bv--&gt;0 = from_bv--&gt;0;</span></span>
<span class="tr"><span class="th" id="line676">676</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (to_bv--&gt;0 == 0) to_bv--&gt;0 = from_bv + WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line677">677</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line678">678</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line679">679</span><span class="td">[ BlkValueCopySB2 to_bv from_bv;</span></span>
<span class="tr"><span class="th" id="line680">680</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_bv--&gt;0 = from_bv--&gt;0;</span></span>
<span class="tr"><span class="th" id="line681">681</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_bv--&gt;1 = from_bv--&gt;1;</span></span>
<span class="tr"><span class="th" id="line682">682</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (to_bv--&gt;1 == 0) to_bv--&gt;1 = from_bv + 2*WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line683">683</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-slow-copy">Slow Copy.</h3><p><p> Why don&#39;t we always do this? Consider the case where B is a list of rooms, and A is a list of objects. If we give A&#39;s short block a pointer to the long block of B, A will suddenly change its kind as well as its contents, because the strong kind of a list is stored inside the long block. So there are a few cases where it&#39;s not safe to make a quick copy. In any case, sooner or later you have to duplicate actual data, not just rearrange pointers to it, and here&#39;s where.<p></p><p> We first call:<p></p><p><div class="pre-lines">kovs(KINDDATA_KOVS, to_bv)</div><p></p><p> which asks for an ID for the kinds stored in the BV: for example, for a list of rooms it would return the kind ID for &quot;room&quot;. We ask for this because it&#39;s information stored in the long block, which is about to be overwritten.<p></p><p> As with the quick copy, we must now make sure any data currently in the destination is properly destroyed. We could do so by making the destination mutable and then destroying its contents, but that would be inefficient, in that it might create a whole lot of temporary copies and then delete them again. So if the long block has a high reference count, we decrement it and then replace the short block (in place) with a fresh one pointing to empty data; we only destroy the contents if the long block has reference count 1.<p></p><p> All of which finally means we can scribble over the destination without spoiling anybody else&#39;s day. We resize it to make room for the incoming data; we copy the raw data of the long block; and finally we:<p></p><p><div class="pre-lines">kovs(COPY_KOVS, to_bv, from_bv, k)</div><p></p><p> This is where the KOVS should make a proper copy, using <span class="fixed"><a href="./BlockValues.i6t.html#line751">BlkValueCopy</a></span> and thus perhaps recursing, if any of that data contained block values in turn: as for instance it will if we&#39;re copying a list of texts. Note that <span class="fixed">k</span> is the value given us by <span class="fixed"><a href="./BlockValues.i6t.html#line508">KINDDATA_KOVS</a></span>.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line724">724</span><span class="td">[ BlkValueSlowCopyPrimitive to_bv from_bv kovs recycling</span></span>
<span class="tr"><span class="th" id="line725">725</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;k from_long_block no_entries_to_copy;</span></span>
<span class="tr"><span class="th" id="line726">726</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;k = kovs(KINDDATA_KOVS, to_bv, from_bv);</span></span>
<span class="tr"><span class="th" id="line727">727</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line728">728</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;from_long_block = BlkValueGetLongBlock(from_bv);</span></span>
<span class="tr"><span class="th" id="line729">729</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (from_long_block) {</span></span>
<span class="tr"><span class="th" id="line730">730</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (recycling) BlkValueRecyclePrimitive(to_bv, kovs);</span></span>
<span class="tr"><span class="th" id="line731">731</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;no_entries_to_copy = kovs(EXTENT_KOVS, from_bv);</span></span>
<span class="tr"><span class="th" id="line732">732</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (no_entries_to_copy == -1) no_entries_to_copy = BlkValueLBCapacity(from_bv);</span></span>
<span class="tr"><span class="th" id="line733">733</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueMassCopyEntries(to_bv, from_bv, no_entries_to_copy);</span></span>
<span class="tr"><span class="th" id="line734">734</span><span class="td"><span class="comment">!print &quot;So to: &quot;; BlkValueDebug(to_bv); print &quot;^&quot;;</span></span></span>
<span class="tr"><span class="th" id="line735">735</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line736">736</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line737">737</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line738">738</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs(COPY_KOVS, to_bv, from_bv, k);</span></span>
<span class="tr"><span class="th" id="line739">739</span><span class="td"><span class="comment">!print &quot;Whence to: &quot;; BlkValueDebug(to_bv); print &quot;^&quot;;</span></span></span>
<span class="tr"><span class="th" id="line740">740</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-copy">Copy.</h3><p><p> As noted above, some copies are quick, and some are slow. We decide by asking the kind&#39;s support function:<p></p><p><div class="pre-lines">kovs(COPYQUICK_KOVS, to_bv, from_bv)</div><p></p><p> which should return true if a quick copy is okay, or false if not.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line751">751</span><span class="td">[ BlkValueCopy to_bv from_bv  to_kind from_kind kovs;</span></span>
<span class="tr"><span class="th" id="line752">752</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (to_bv == 0) BlkValueError(<span class="dstring">&quot;copy to null value&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line753">753</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (from_bv == 0) BlkValueError(<span class="dstring">&quot;copy from null value&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line754">754</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (to_bv == from_bv) return;</span></span>
<span class="tr"><span class="th" id="line755">755</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line756">756</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;#ifdef BLKVALUE_TRACE;</span></span>
<span class="tr"><span class="th" id="line757">757</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;print <span class="dstring">&quot;Copy: &quot;</span>, (BlkValueDebug) to_bv, <span class="dstring">&quot; to equal &quot;</span>, (BlkValueDebug) from_bv, <span class="dstring">&quot;^&quot;</span>;</span></span>
<span class="tr"><span class="th" id="line758">758</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;#endif;</span></span>
<span class="tr"><span class="th" id="line759">759</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line760">760</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;to_kind = BlkValueWeakKind(to_bv);</span></span>
<span class="tr"><span class="th" id="line761">761</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;from_kind = BlkValueWeakKind(from_bv);</span></span>
<span class="tr"><span class="th" id="line762">762</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (to_kind ~= from_kind) BlkValueError(<span class="dstring">&quot;copy incompatible kinds&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line763">763</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line764">764</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs = KOVSupportFunction(to_kind, <span class="dstring">&quot;impossible copy&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line765">765</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;</span></span>
<span class="tr"><span class="th" id="line766">766</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (kovs(COPYQUICK_KOVS, to_bv, from_bv))</span></span>
<span class="tr"><span class="th" id="line767">767</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueQuickCopyPrimitive(to_bv, from_bv, kovs);</span></span>
<span class="tr"><span class="th" id="line768">768</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else</span></span>
<span class="tr"><span class="th" id="line769">769</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueSlowCopyPrimitive(to_bv, from_bv, kovs, true);</span></span>
<span class="tr"><span class="th" id="line770">770</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line771">771</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return to_bv;</span></span>
<span class="tr"><span class="th" id="line772">772</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line773">773</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line774">774</span><span class="td">[ BlkValueCopyAZ to_bv from_bv;</span></span>
<span class="tr"><span class="th" id="line775">775</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (from_bv) return BlkValueCopy(to_bv, from_bv);</span></span>
<span class="tr"><span class="th" id="line776">776</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return to_bv;</span></span>
<span class="tr"><span class="th" id="line777">777</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-destruction">Destruction.</h3><p><p> We will also need primitives for two different forms of destruction. This is something which should happen whenever a block value is thrown away, not to be used again: either because it&#39;s being freed, or because new contents are being copied into it.<p></p><p> The idea of destruction is that any data stored in the long block should safely be disposed of. If the reference count of the long block is 2 or more, there&#39;s no problem, because we can simply decrement the count and let other people worry about the data from now on. But if it&#39;s only 1, then destroying the data is on us. Since we don&#39;t know what&#39;s in the long block, we have to ask the KOVS to do this by means of:<p></p><p><div class="pre-lines">kovs(DESTROY_KOVS, bv)</div><p></p><p> Note that all of this frequently causes recursion: destruction leads to freeing of some of the data, which in turn means that that data must be destroyed, and so on. So it&#39;s essential that block values be well-founded: a list must not, for example, contain itself.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line800">800</span><span class="td">[ BlkValueDestroyPrimitive bv kovs long_block;</span></span>
<span class="tr"><span class="th" id="line801">801</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;#ifdef BLKVALUE_TRACE; print <span class="dstring">&quot;Destroying &quot;</span>, (BlkValueDebug) bv, <span class="dstring">&quot;^&quot;</span>; #endif;</span></span>
<span class="tr"><span class="th" id="line802">802</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (BlkValueDecRefCountPrimitive(bv) == 0) {</span></span>
<span class="tr"><span class="th" id="line803">803</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kovs(DESTROY_KOVS, bv);</span></span>
<span class="tr"><span class="th" id="line804">804</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long_block = BlkValueGetLongBlock(bv);</span></span>
<span class="tr"><span class="th" id="line805">805</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (long_block) FlexFree(long_block);</span></span>
<span class="tr"><span class="th" id="line806">806</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line807">807</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-recycling">Recycling.</h3><p><p> This is like destruction in that it disposes of the value safely, but it tries to keep the long block for reuse, rather than deallocating it. This won&#39;t work if other people are still using it, so in the case where its reference count is 2 or more, we simply reduce the count by 1 and then replace the small block with a new one (at the same address).<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line817">817</span><span class="td">[ BlkValueRecyclePrimitive bv kovs;</span></span>
<span class="tr"><span class="th" id="line818">818</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;#ifdef BLKVALUE_TRACE; print <span class="dstring">&quot;Recycling &quot;</span>, (BlkValueDebug) bv, <span class="dstring">&quot;^&quot;</span>; #endif;</span></span>
<span class="tr"><span class="th" id="line819">819</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (BlkValueDecRefCountPrimitive(bv) == 0) {</span></span>
<span class="tr"><span class="th" id="line820">820</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kovs(DESTROY_KOVS, bv);</span></span>
<span class="tr"><span class="th" id="line821">821</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueIncRefCountPrimitive(bv);</span></span>
<span class="tr"><span class="th" id="line822">822</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;} else {</span></span>
<span class="tr"><span class="th" id="line823">823</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueCreate(BlkValueWeakKind(bv), bv);</span></span>
<span class="tr"><span class="th" id="line824">824</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line825">825</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-mutability">Mutability.</h3><p><p> A block value is by definition mutable if it has a long block with reference count 1, because then the data in the long block can freely be changed without corrupting other block values.<p></p><p> We offer the KOVS a chance to handle this for us:<p></p><p><div class="pre-lines">kovs(MAKEMUTABLE_KOVS, bv)</div><p></p><p> should return 0 to say that it has done so, or else return the size of the short block in words to ask us to handle it. The way we do this is to create a temporary value to make a safe copy into; it would be unnecessarily slow to allocate the short block for this safe copy on the heap and then free it again moments later, so instead we put the short block on the stack, making a temporary one-value stack frame instead to hold it.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line844">844</span><span class="td">[ BlkMakeMutable bv block bv_kind kovs sb_size;</span></span>
<span class="tr"><span class="th" id="line845">845</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (bv == 0) BlkValueError(<span class="dstring">&quot;tried to make null block mutable&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line846">846</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line847">847</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (BlkValueGetRefCountPrimitive(bv) &gt; 1) {</span></span>
<span class="tr"><span class="th" id="line848">848</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef BLKVALUE_TRACE; print <span class="dstring">&quot;Make mutable: &quot;</span>, (BlkValueDebug) bv, <span class="dstring">&quot;^&quot;</span>; #endif;</span></span>
<span class="tr"><span class="th" id="line849">849</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line850">850</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueDecRefCountPrimitive(bv);</span></span>
<span class="tr"><span class="th" id="line851">851</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line852">852</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bv_kind = BlkValueWeakKind(bv);</span></span>
<span class="tr"><span class="th" id="line853">853</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kovs = KOVSupportFunction(bv_kind, <span class="dstring">&quot;impossible mutability&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line854">854</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line855">855</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb_size = kovs(MAKEMUTABLE_KOVS, bv);</span></span>
<span class="tr"><span class="th" id="line856">856</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (sb_size &gt; 0) {</span></span>
<span class="tr"><span class="th" id="line857">857</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@push I7SFRAME;</span></span>
<span class="tr"><span class="th" id="line858">858</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StackFrameCreate(sb_size);</span></span>
<span class="tr"><span class="th" id="line859">859</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueCreateOnStack(0, bv_kind);</span></span>
<span class="tr"><span class="th" id="line860">860</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kovs(COPYKIND_KOVS, I7SFRAME, bv);</span></span>
<span class="tr"><span class="th" id="line861">861</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueSlowCopyPrimitive(I7SFRAME, bv, kovs, false);</span></span>
<span class="tr"><span class="th" id="line862">862</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kovs(COPYSB_KOVS, bv, I7SFRAME);</span></span>
<span class="tr"><span class="th" id="line863">863</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@pull I7SFRAME;</span></span>
<span class="tr"><span class="th" id="line864">864</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line865">865</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line866">866</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-casting">Casting.</h3><p><p> We can also perform an assignment to an already-created block value in the form of a cast, that is, a conversion of data from one kind to another: or at least, for some kinds of value we can.<p></p><p><div class="pre-lines">kovs(CAST_KOVS, to_bv, original_kind, original_value)</div><p></p><p> casts from the given value, with the given kind, into the existing block value <span class="fixed">to_bv</span>. Note that the source value doesn&#39;t need to be a BV itself. This mechanism is used, for example, to cast snippets to text.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line880">880</span><span class="td">[ BlkValueCast to_bv original_kind original_value  kovs;</span></span>
<span class="tr"><span class="th" id="line881">881</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs = KOVSupportFunction(BlkValueWeakKind(to_bv), <span class="dstring">&quot;impossible cast&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line882">882</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs(CAST_KOVS, to_bv, original_kind, original_value);</span></span>
<span class="tr"><span class="th" id="line883">883</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return to_bv;</span></span>
<span class="tr"><span class="th" id="line884">884</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-comparison">Comparison.</h3><p><p> And it&#39;s a similar story with comparison:<p></p><p><div class="pre-lines">kovs(COMPARE_KOVS, bv_left, bv_right)</div><p></p><p> looks at the data in the two BVs and returns 0 if they are equal, a positive number if <span class="fixed">bv_right</span> is &quot;greater than&quot; <span class="fixed">bv_left</span>, and a negative number if not. The interpretation of &quot;greater than&quot; depends on the kind, but should be something which the user would find natural.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line897">897</span><span class="td">[ BlkValueCompare bv_left bv_right  kind_left kind_right kovs;</span></span>
<span class="tr"><span class="th" id="line898">898</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if ((bv_left == 0) &amp;&amp; (bv_right == 0)) return 0;</span></span>
<span class="tr"><span class="th" id="line899">899</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (bv_left == 0) return 1;</span></span>
<span class="tr"><span class="th" id="line900">900</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (bv_right == 0) return -1;</span></span>
<span class="tr"><span class="th" id="line901">901</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line902">902</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kind_left = BlkValueWeakKind(bv_left);</span></span>
<span class="tr"><span class="th" id="line903">903</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kind_right = BlkValueWeakKind(bv_right);</span></span>
<span class="tr"><span class="th" id="line904">904</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (kind_left ~= kind_right) return kind_left - kind_right;</span></span>
<span class="tr"><span class="th" id="line905">905</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line906">906</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs = KOVSupportFunction(kind_left, <span class="dstring">&quot;impossible comparison&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line907">907</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return kovs(COMPARE_KOVS, bv_left, bv_right);</span></span>
<span class="tr"><span class="th" id="line908">908</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-hashing">Hashing.</h3><p><p> Given a value of any kind, assign it a hash code which fits in a single virtual machine word, maximizing the chances that two different values will have different hash codes.<p></p><p> If the value can be stored in a single word already, it can be its own hash code. Otherwise, we ask:<p></p><p><div class="pre-lines">kovs(HASH_KOVS, bv)</div><p></p><p> to return one for us. Whatever this does, it must at minimum have the property that two equivalent blocks (for which <span class="fixed"><a href="./BlockValues.i6t.html#line510">COMPARE_KOVS</a></span> returns 0) produce the same hash value.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line925">925</span><span class="td">[ GetHashValue kind value;</span></span>
<span class="tr"><span class="th" id="line926">926</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (KOVIsBlockValue(kind)) return BlkValueHash(value);</span></span>
<span class="tr"><span class="th" id="line927">927</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return value;</span></span>
<span class="tr"><span class="th" id="line928">928</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line929">929</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line930">930</span><span class="td">[ BlkValueHash bv  bv_kind kovs;</span></span>
<span class="tr"><span class="th" id="line931">931</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (bv == 0) return 0;</span></span>
<span class="tr"><span class="th" id="line932">932</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;bv_kind = BlkValueWeakKind(bv);</span></span>
<span class="tr"><span class="th" id="line933">933</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs = KOVSupportFunction(bv_kind, <span class="dstring">&quot;impossible hashing&quot;</span>);</span></span>
<span class="tr"><span class="th" id="line934">934</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;return kovs(HASH_KOVS, bv);</span></span>
<span class="tr"><span class="th" id="line935">935</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-serialisation">Serialisation.</h3><p><p> Some block values can be written to external files (on Glulx): others cannot. The following routines abstract that.<p></p><p> If <span class="fixed">ch</span> is <em>-1</em>, then:<p></p><p><div class="pre-lines">kovs(READ_FILE_KOVS, bv, auxf, ch)</div><p></p><p> returns <span class="fixed">true</span> or <span class="fixed">false</span> according to whether it is possible to read data from an auxiliary file <span class="fixed">auxf</span> into the block value <span class="fixed">bv</span>. If <span class="fixed">ch</span> is any other value, then the routine should do exactly that, taking <span class="fixed">ch</span> to be the first character of the text read from the file which makes up the serialised form of the data.<p></p><p><div class="pre-lines">kovs(WRITE_FILE_KOVS, bv)</div><p></p><p> is simpler because, strictly speaking, it doesn&#39;t write to a file at all: it simply prints a serialised form of the data in <span class="fixed">bv</span> to the output stream. Since it is called only when that output stream has been redirected to an auxiliary file, and since the serialised form would often be illegible on screen, it seems reasonable to call it a file input-output function just the same. The <span class="fixed"><a href="./BlockValues.i6t.html#line512">WRITE_FILE_KOVS</a></span> should return <span class="fixed">true</span> or <span class="fixed">false</span> according to whether it was able to write the data.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line962">962</span><span class="td">[ BlkValueReadFromFile bv auxf ch bv_kind  kovs;</span></span>
<span class="tr"><span class="th" id="line963">963</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs = KOVSupportFunction(bv_kind);</span></span>
<span class="tr"><span class="th" id="line964">964</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (kovs) return kovs(READ_FILE_KOVS, bv, auxf, ch);</span></span>
<span class="tr"><span class="th" id="line965">965</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line966">966</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line967">967</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line968">968</span><span class="td">[ BlkValueWriteToFile bv bv_kind  kovs;</span></span>
<span class="tr"><span class="th" id="line969">969</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;kovs = KOVSupportFunction(bv_kind);</span></span>
<span class="tr"><span class="th" id="line970">970</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (kovs) return kovs(WRITE_FILE_KOVS, bv);</span></span>
<span class="tr"><span class="th" id="line971">971</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line972">972</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-debugging">Debugging.</h3><p><p> Surprisingly, the above system of reference-counted double indirection didn&#39;t work first time, so it turned out to be useful to have these routines on hand.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line979">979</span><span class="td">[ BlkValueDebug bv flag refc long_block kovs;</span></span>
<span class="tr"><span class="th" id="line980">980</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;print <span class="dstring">&quot;(BV&quot;</span>;</span></span>
<span class="tr"><span class="th" id="line981">981</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (bv) {</span></span>
<span class="tr"><span class="th" id="line982">982</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkDebugAddress(bv, flag);</span></span>
<span class="tr"><span class="th" id="line983">983</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long_block = BlkValueGetLongBlock(bv);</span></span>
<span class="tr"><span class="th" id="line984">984</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (long_block) {</span></span>
<span class="tr"><span class="th" id="line985">985</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (bv--&gt;0 == 0) print <span class="dstring">&quot;...&quot;</span>; else print <span class="dstring">&quot;--&gt;&quot;</span>;</span></span>
<span class="tr"><span class="th" id="line986">986</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print <span class="dstring">&quot;L&quot;</span>; BlkDebugAddress(long_block, flag);</span></span>
<span class="tr"><span class="th" id="line987">987</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print <span class="dstring">&quot; 2**&quot;</span>, long_block-&gt;BLK_HEADER_N;</span></span>
<span class="tr"><span class="th" id="line988">988</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refc = BlkValueGetRefCountPrimitive(bv);</span></span>
<span class="tr"><span class="th" id="line989">989</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (refc == RC_INFINITY) print <span class="dstring">&quot; resident&quot;</span>;</span></span>
<span class="tr"><span class="th" id="line990">990</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else { print <span class="dstring">&quot; &quot;</span>, refc, <span class="dstring">&quot; ref&quot;</span>; if (refc ~= 1) print <span class="dstring">&quot;s&quot;</span>; }</span></span>
<span class="tr"><span class="th" id="line991">991</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line992">992</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kovs = KOVSupportFunction(BlkValueWeakKind(bv));</span></span>
<span class="tr"><span class="th" id="line993">993</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (kovs) kovs(DEBUG_KOVS, bv);</span></span>
<span class="tr"><span class="th" id="line994">994</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line995">995</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;print <span class="dstring">&quot;)&quot;</span>;</span></span>
<span class="tr"><span class="th" id="line996">996</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-printing-memory-addresses">Printing Memory Addresses.</h3><p><p> The point of the anonymity flag is that, with this set, the output can be used as the required output in an Inform test case without tiny movements in memory between builds invalidating this required output.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line1004">1004</span><span class="td">[ BlkDebugAddress addr flag d;</span></span>
<span class="tr"><span class="th" id="line1005">1005</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (flag) { print <span class="dstring">&quot;###&quot;</span>; return; }</span></span>
<span class="tr"><span class="th" id="line1006">1006</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line1007">1007</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;d = addr - blockv_stack;</span></span>
<span class="tr"><span class="th" id="line1008">1008</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if ((d &gt;= 0) &amp;&amp; (d &lt;= WORDSIZE*BLOCKV_STACK_SIZE)) {</span></span>
<span class="tr"><span class="th" id="line1009">1009</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print <span class="dstring">&quot;s+&quot;</span>, (BlkPrintHexadecimal) d;</span></span>
<span class="tr"><span class="th" id="line1010">1010</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d = addr - I7SFRAME;</span></span>
<span class="tr"><span class="th" id="line1011">1011</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print <span class="dstring">&quot;=f&quot;</span>; if (d &gt;= 0) print <span class="dstring">&quot;+&quot;</span>; print d;</span></span>
<span class="tr"><span class="th" id="line1012">1012</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span></span>
<span class="tr"><span class="th" id="line1013">1013</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1014">1014</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;</span></span>
<span class="tr"><span class="th" id="line1015">1015</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;d = addr - Flex_Heap;</span></span>
<span class="tr"><span class="th" id="line1016">1016</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if ((d &gt;= 0) &amp;&amp; (d &lt; MEMORY_HEAP_SIZE + 16)) {</span></span>
<span class="tr"><span class="th" id="line1017">1017</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print <span class="dstring">&quot;h+&quot;</span>, (BlkPrintHexadecimal) d;</span></span>
<span class="tr"><span class="th" id="line1018">1018</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</span></span>
<span class="tr"><span class="th" id="line1019">1019</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1020">1020</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line1021">1021</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;print (BlkPrintHexadecimal) addr;</span></span>
<span class="tr"><span class="th" id="line1022">1022</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#blockvalues-hexadecimal-printing">Hexadecimal Printing.</h3><p><p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line1027">1027</span><span class="td">[ BlkPrintHexadecimal v;</span></span>
<span class="tr"><span class="th" id="line1028">1028</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;#iftrue WORDSIZE == 4;</span></span>
<span class="tr"><span class="th" id="line1029">1029</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (v &amp; $ffff0000) {</span></span>
<span class="tr"><span class="th" id="line1030">1030</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (v &amp; $ff000000) {</span></span>
<span class="tr"><span class="th" id="line1031">1031</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkPrintHexDigit(v / $10000000);</span></span>
<span class="tr"><span class="th" id="line1032">1032</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkPrintHexDigit(v / $1000000);</span></span>
<span class="tr"><span class="th" id="line1033">1033</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1034">1034</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkPrintHexDigit(v / $100000);</span></span>
<span class="tr"><span class="th" id="line1035">1035</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkPrintHexDigit(v / $10000);</span></span>
<span class="tr"><span class="th" id="line1036">1036</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1037">1037</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;#endif;</span></span>
<span class="tr"><span class="th" id="line1038">1038</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkPrintHexDigit(v / $1000);</span></span>
<span class="tr"><span class="th" id="line1039">1039</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkPrintHexDigit(v / $100);</span></span>
<span class="tr"><span class="th" id="line1040">1040</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkPrintHexDigit(v / $10);</span></span>
<span class="tr"><span class="th" id="line1041">1041</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkPrintHexDigit(v);</span></span>
<span class="tr"><span class="th" id="line1042">1042</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line1043">1043</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line1044">1044</span><span class="td">[ BlkPrintHexDigit v;</span></span>
<span class="tr"><span class="th" id="line1045">1045</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;v = v &amp; $F;</span></span>
<span class="tr"><span class="th" id="line1046">1046</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if (v &lt; 10) print v; else print (char) <span class="sstring">&#39;A&#39;</span> + v - 10;</span></span>
<span class="tr"><span class="th" id="line1047">1047</span><span class="td">];</span></span>
</div><footer><p><em>From I6T lib 6/12N &copy; Graham Nelson and published under the <a href="https://github.com/zedlopez/standard_rules/blob/main/LICENSE.md">Artistic License 2.0</a>. Distributed with <a href="http://inform7.com/">Inform 7 6M62</a>.</em></p></footer></body></html>
