<!doctype html>
<html lang="en">
<meta charset="utf-8">
<head><title>Text</title>
  <style>
span.th, span.td { display: table-cell; }
span.td { padding-left: 2rem; }
span.th { width:4rem; text-align: right; }
span.tr { display: table-row;     counter-increment: linenum; }
span.line_no::before {
    content: counter(linenum);
    text-align: right;
    display: block;
    font-family: monospace;
    font-weight: normal;
}
h1 { margin: 0; }
.fixed { font-family: monospace }
.em { font-style: italic; }
.center { text-align: center; }
    body { font-family: sans-serif; margin: 1.5rem 0 0 3rem; background-color: #fafaf0; width: 80rem; }
    .pre { font-family: monospace; margin: auto; width: 80rem; }
#front_matter,.text { width: 50rem; }
.text { border-bottom: .5px solid black; border-top: .5px solid black; margin-top: 1rem;
padding-bottom: 1rem; margin-bottom: 2rem; }
/*.subtitle { font-weight: bold; font-size: 1.2rem; }*/
    </style>
</head>
<body>
<header>
<h1>I6 Template Layer</h1>
<div class="subtitle"><a href="http://inform7.com/">Inform 7 6M62</a> &bull; <a href="./index.html">Index</a> &bull; <a href="./Introduction.i6t.html">Introduction</a></div><hr></header>
<div id="front_matter">
<h2><a href="./Text.i6t">Text.i6t</a></h2><h3 id="#text-block-format">Block Format.</h3><p><p> The short block for a text is two words long: the first word selects which form of storage will be used to represent the content, and the second word is a reference to that content. This reference is an I6 String or Routine in all cases except one, when it&#39;s a pointer to a long block containing a null-terminated array of characters, like a C string.<p></p><p> Clearly we need <span class="fixed"><a href="./Text.i6t.html#line35">PACKED_TEXT_STORAGE</a></span> and <span class="fixed"><a href="./Text.i6t.html#line36">UNPACKED_TEXT_STORAGE</a></span> to distinguish between the two basic methods of text storage, roughly equivalent to the pre-2013 kinds &quot;text&quot; and &quot;indexed text&quot;. But why do we need four?<p></p><p> <span class="fixed"><a href="./Text.i6t.html#line33">CONSTANT_PACKED_TEXT_STORAGE</a></span> is easy to explain: the BlkValue routines normally detect constants using metadata in their long blocks, but of course that won&#39;t work for values which haven&#39;t got any long blocks.We use this instead. We don&#39;t need a <span class="fixed">CONSTANT_UNPACKED_TEXT_STORAGE</span><br> because I7 never compiles constant text in unpacked form.<p></p><p> The surprising one is <span class="fixed"><a href="./Text.i6t.html#line34">CONSTANT_PERISHABLE_TEXT_STORAGE</a></span>. This is a constant created by the I7 compiler which is marked as being tricky because its value is a text substitution containing references to local variables. Unlike other text substitutions, this can&#39;t meaningfully be stored away to be expanded later: it must be expanded into unpacked text before it perishes.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line33">33</span><span class="td">Constant&nbsp;CONSTANT_PACKED_TEXT_STORAGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;BLK_BVBITMAP_TEXT&nbsp;+&nbsp;BLK_BVBITMAP_CONSTANT&nbsp;+&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line34">34</span><span class="td">Constant&nbsp;CONSTANT_PERISHABLE_TEXT_STORAGE&nbsp;=&nbsp;BLK_BVBITMAP_TEXT&nbsp;+&nbsp;BLK_BVBITMAP_CONSTANT&nbsp;+&nbsp;2;</span></span>
<span class="tr"><span class="th" id="line35">35</span><span class="td">Constant&nbsp;PACKED_TEXT_STORAGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;BLK_BVBITMAP_TEXT&nbsp;+&nbsp;3;</span></span>
<span class="tr"><span class="th" id="line36">36</span><span class="td">Constant&nbsp;UNPACKED_TEXT_STORAGE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;BLK_BVBITMAP_TEXT&nbsp;+&nbsp;BLK_BVBITMAP_LONGBLOCK&nbsp;+&nbsp;4;</span></span>
</div><div class='text'>
<h3 id="#text-extent-of-long-block">Extent Of Long Block.</h3><p><p> When there&#39;s a long block, we need enough of the entries to store the number of characters, plus one for the null terminator.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line43">43</span><span class="td">[&nbsp;TEXT_TY_Extent&nbsp;arg1&nbsp;x;</span></span>
<span class="tr"><span class="th" id="line44">44</span><span class="td">&nbsp;x&nbsp;=&nbsp;BlkValueSeekZeroEntry(arg1);</span></span>
<span class="tr"><span class="th" id="line45">45</span><span class="td">&nbsp;if&nbsp;(x&nbsp;&lt;&nbsp;0)&nbsp;return&nbsp;-1;&nbsp;!&nbsp;should&nbsp;not&nbsp;happen,&nbsp;of&nbsp;course</span></span>
<span class="tr"><span class="th" id="line46">46</span><span class="td">&nbsp;return&nbsp;x+1;</span></span>
<span class="tr"><span class="th" id="line47">47</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-character-set">Character Set.</h3><p><p> On the Z-machine, we use the 8-bit ZSCII character set, stored in bytes; on Glulx, we use the opening 16-bit subset of Unicode (which though only a subset covers almost all letter forms used on Earth), stored in half-words.<p></p><p> The Z-machine does have very partial Unicode support, but not in a way that can help us here. It is capable of printing a wide range of Unicode characters, and on a good interpreter with a good font (such as Zoom for Mac OS X, using the Lucida Grande font) can produce many thousands of glyphs. But it is not capable of printing those characters into memory rather than the screen, an essential technique for texts: it can only write each character to a single byte, and it does so in ZSCII. That forces our hand when it comes to choosing the indexed-text character set.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line64">64</span><span class="td">#IFDEF&nbsp;TARGET_ZCODE;</span></span>
<span class="tr"><span class="th" id="line65">65</span><span class="td">Constant&nbsp;TEXT_TY_Storage_Flags&nbsp;=&nbsp;BLK_FLAG_MULTIPLE;</span></span>
<span class="tr"><span class="th" id="line66">66</span><span class="td">Constant&nbsp;ZSCII_Tables;</span></span>
<span class="tr"><span class="th" id="line67">67</span><span class="td">#IFNOT;</span></span>
<span class="tr"><span class="th" id="line68">68</span><span class="td">Constant&nbsp;TEXT_TY_Storage_Flags&nbsp;=&nbsp;BLK_FLAG_MULTIPLE&nbsp;+&nbsp;BLK_FLAG_16_BIT;</span></span>
<span class="tr"><span class="th" id="line69">69</span><span class="td">Constant&nbsp;Large_Unicode_Tables;</span></span>
<span class="tr"><span class="th" id="line70">70</span><span class="td">#ENDIF;</span></span>
<span class="tr"><span class="th" id="line71">71</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line72">72</span><span class="td">{-segment:<a&nbsp;href="./UnicodeData.html">UnicodeData.i6t</a>}</span></span>
<span class="tr"><span class="th" id="line73">73</span><span class="td">{-segment:<a&nbsp;href="./Char.html">Char.i6t</a>}</span></span>
</div><div class='text'>
<h3 id="#text-kov-support">KOV Support.</h3><p><p> See the <a href="./BlockValues.i6t.html">BlockValues.i6t</a> segment for the specification of the following routines. Because no block values are ever stored in a text, they can freely be bitwise copied or forgotten, which is why we need do nothing special to copy or destroy a text.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line82">82</span><span class="td">[&nbsp;TEXT_TY_Support&nbsp;task&nbsp;arg1&nbsp;arg2&nbsp;arg3;</span></span>
<span class="tr"><span class="th" id="line83">83</span><span class="td">&nbsp;switch(task)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line84">84</span><span class="td">&nbsp;&nbsp;CREATE_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TEXT_TY_Create(arg2);</span></span>
<span class="tr"><span class="th" id="line85">85</span><span class="td">&nbsp;&nbsp;CAST_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEXT_TY_Cast(arg1,&nbsp;arg2,&nbsp;arg3);</span></span>
<span class="tr"><span class="th" id="line86">86</span><span class="td">&nbsp;&nbsp;MAKEMUTABLE_KOVS:&nbsp;return&nbsp;TEXT_TY_Mutable(arg1);</span></span>
<span class="tr"><span class="th" id="line87">87</span><span class="td">&nbsp;&nbsp;COPYQUICK_KOVS:&nbsp;&nbsp;&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line88">88</span><span class="td">&nbsp;&nbsp;COPYSB_KOVS:&nbsp;&nbsp;&nbsp;TEXT_TY_CopySB(arg1,&nbsp;arg2);</span></span>
<span class="tr"><span class="th" id="line89">89</span><span class="td">&nbsp;&nbsp;KINDDATA_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line90">90</span><span class="td">&nbsp;&nbsp;EXTENT_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TEXT_TY_Extent(arg1);</span></span>
<span class="tr"><span class="th" id="line91">91</span><span class="td">&nbsp;&nbsp;COMPARE_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TEXT_TY_Compare(arg1,&nbsp;arg2);</span></span>
<span class="tr"><span class="th" id="line92">92</span><span class="td">&nbsp;&nbsp;READ_FILE_KOVS:&nbsp;&nbsp;&nbsp;if&nbsp;(arg3&nbsp;==&nbsp;-1)&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line93">93</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TEXT_TY_ReadFile(arg1,&nbsp;arg2,&nbsp;arg3);</span></span>
<span class="tr"><span class="th" id="line94">94</span><span class="td">&nbsp;&nbsp;WRITE_FILE_KOVS:&nbsp;&nbsp;return&nbsp;TEXT_TY_WriteFile(arg1);</span></span>
<span class="tr"><span class="th" id="line95">95</span><span class="td">&nbsp;&nbsp;HASH_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;TEXT_TY_Hash(arg1);</span></span>
<span class="tr"><span class="th" id="line96">96</span><span class="td">&nbsp;&nbsp;DEBUG_KOVS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEXT_TY_Debug(arg1);</span></span>
<span class="tr"><span class="th" id="line97">97</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line98">98</span><span class="td">&nbsp;!&nbsp;We&nbsp;choose&nbsp;not&nbsp;to&nbsp;respond&nbsp;to:&nbsp;DESTROY_KOVS,&nbsp;COPYKIND_KOVS,&nbsp;COPY_KOVS</span></span>
<span class="tr"><span class="th" id="line99">99</span><span class="td">&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line100">100</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-debugging">Debugging.</h3><p><p> This shows the various forms a text&#39;s short block can take:<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line106">106</span><span class="td">[&nbsp;TEXT_TY_Debug&nbsp;txt;</span></span>
<span class="tr"><span class="th" id="line107">107</span><span class="td">&nbsp;switch&nbsp;(txt--&gt;0)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line108">108</span><span class="td">&nbsp;&nbsp;CONSTANT_PACKED_TEXT_STORAGE:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;&nbsp;=&nbsp;cp~&quot;,&nbsp;(PrintI6Text)&nbsp;txt--&gt;1,&nbsp;&quot;~&quot;;</span></span>
<span class="tr"><span class="th" id="line109">109</span><span class="td">&nbsp;&nbsp;CONSTANT_PERISHABLE_TEXT_STORAGE:&nbsp;print&nbsp;&quot;&nbsp;=&nbsp;cp~&quot;,&nbsp;(PrintI6Text)&nbsp;txt--&gt;1,&nbsp;&quot;~&quot;;</span></span>
<span class="tr"><span class="th" id="line110">110</span><span class="td">&nbsp;&nbsp;PACKED_TEXT_STORAGE:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;&nbsp;=&nbsp;p~&quot;,&nbsp;(PrintI6Text)&nbsp;txt--&gt;1,&nbsp;&quot;~&quot;;</span></span>
<span class="tr"><span class="th" id="line111">111</span><span class="td">&nbsp;&nbsp;UNPACKED_TEXT_STORAGE:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;&nbsp;=&nbsp;~&quot;,&nbsp;(TEXT_TY_Say)&nbsp;txt,&nbsp;&quot;~&quot;;</span></span>
<span class="tr"><span class="th" id="line112">112</span><span class="td">&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&quot;&nbsp;broken?&quot;;</span></span>
<span class="tr"><span class="th" id="line113">113</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line114">114</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-creation">Creation.</h3><p><p> A newly created text is a two-word short block with no long block, like this:<p></p><p>	<span class="fixed">Array ThisIsAText --&gt; PACKED_TEXT_STORAGE EMPTY_TEXT_PACKED;</span><br><p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line122">122</span><span class="td">[&nbsp;TEXT_TY_Create&nbsp;short_block&nbsp;x;</span></span>
<span class="tr"><span class="th" id="line123">123</span><span class="td">&nbsp;return&nbsp;BlkValueCreateSB2(short_block,&nbsp;PACKED_TEXT_STORAGE,&nbsp;EMPTY_TEXT_PACKED);</span></span>
<span class="tr"><span class="th" id="line124">124</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-copy-short-block">Copy Short Block.</h3><p><p> When a short block for a constant is copied, the new copy isn&#39;t a constant any more.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line131">131</span><span class="td">[&nbsp;TEXT_TY_CopySB&nbsp;to_bv&nbsp;from_bv;</span></span>
<span class="tr"><span class="th" id="line132">132</span><span class="td">&nbsp;BlkValueCopySB2(to_bv,&nbsp;from_bv);</span></span>
<span class="tr"><span class="th" id="line133">133</span><span class="td">&nbsp;if&nbsp;(to_bv--&gt;0&nbsp;&amp;&nbsp;BLK_BVBITMAP_CONSTANTMASK)&nbsp;to_bv--&gt;0&nbsp;=&nbsp;PACKED_TEXT_STORAGE;</span></span>
<span class="tr"><span class="th" id="line134">134</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-transmutation">Transmutation.</h3><p><p> What happens if a text is stored in packed form, but we need to access or change its individual characters? The answer is that we have to &quot;transmute&quot; it into long block form. Sometimes this is a permanent change, but often it&#39;s only temporary, and will soon be followed by an un-transmutation.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line143">143</span><span class="td">[&nbsp;TEXT_TY_Transmute&nbsp;txt;</span></span>
<span class="tr"><span class="th" id="line144">144</span><span class="td">&nbsp;TEXT_TY_Temporarily_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line145">145</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line146">146</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line147">147</span><span class="td">[&nbsp;TEXT_TY_Temporarily_Transmute&nbsp;txt&nbsp;&nbsp;x;</span></span>
<span class="tr"><span class="th" id="line148">148</span><span class="td">&nbsp;if&nbsp;((txt)&nbsp;&amp;&amp;&nbsp;(txt--&gt;0&nbsp;&amp;&nbsp;BLK_BVBITMAP_LONGBLOCKMASK&nbsp;==&nbsp;0))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line149">149</span><span class="td">&nbsp;&nbsp;x&nbsp;=&nbsp;txt--&gt;1;&nbsp;!&nbsp;The&nbsp;old&nbsp;value&nbsp;was&nbsp;a&nbsp;packed&nbsp;string</span></span>
<span class="tr"><span class="th" id="line150">150</span><span class="td">&nbsp;&nbsp;</span></span>
<span class="tr"><span class="th" id="line151">151</span><span class="td">&nbsp;&nbsp;txt--&gt;0&nbsp;=&nbsp;UNPACKED_TEXT_STORAGE;</span></span>
<span class="tr"><span class="th" id="line152">152</span><span class="td">&nbsp;&nbsp;txt--&gt;1&nbsp;=&nbsp;FlexAllocate(32,&nbsp;TEXT_TY,&nbsp;TEXT_TY_Storage_Flags);</span></span>
<span class="tr"><span class="th" id="line153">153</span><span class="td">&nbsp;&nbsp;if&nbsp;(x&nbsp;~=&nbsp;EMPTY_TEXT_PACKED)&nbsp;TEXT_TY_CastPrimitive(txt,&nbsp;false,&nbsp;x);</span></span>
<span class="tr"><span class="th" id="line154">154</span><span class="td">&nbsp;&nbsp;</span></span>
<span class="tr"><span class="th" id="line155">155</span><span class="td">&nbsp;&nbsp;return&nbsp;x;</span></span>
<span class="tr"><span class="th" id="line156">156</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line157">157</span><span class="td">&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line158">158</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line159">159</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line160">160</span><span class="td">[&nbsp;TEXT_TY_Untransmute&nbsp;txt&nbsp;pk&nbsp;cp&nbsp;x;</span></span>
<span class="tr"><span class="th" id="line161">161</span><span class="td">&nbsp;if&nbsp;((pk)&nbsp;&amp;&amp;&nbsp;(txt--&gt;0&nbsp;==&nbsp;UNPACKED_TEXT_STORAGE))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line162">162</span><span class="td">&nbsp;&nbsp;x&nbsp;=&nbsp;txt--&gt;1;&nbsp;!&nbsp;The&nbsp;old&nbsp;value&nbsp;was&nbsp;an&nbsp;unpacked&nbsp;string</span></span>
<span class="tr"><span class="th" id="line163">163</span><span class="td">&nbsp;&nbsp;FlexFree(x);</span></span>
<span class="tr"><span class="th" id="line164">164</span><span class="td">&nbsp;&nbsp;txt--&gt;0&nbsp;=&nbsp;cp;</span></span>
<span class="tr"><span class="th" id="line165">165</span><span class="td">&nbsp;&nbsp;txt--&gt;1&nbsp;=&nbsp;pk;&nbsp;!&nbsp;The&nbsp;value&nbsp;earlier&nbsp;returned&nbsp;by&nbsp;TEXT_TY_Temporarily_Transmute</span></span>
<span class="tr"><span class="th" id="line166">166</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line167">167</span><span class="td">&nbsp;return&nbsp;txt;</span></span>
<span class="tr"><span class="th" id="line168">168</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-mutability">Mutability.</h3><p><p> That neatly handles the question of how to make a text mutable. (Note that constants are never created in unpacked form.)<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line175">175</span><span class="td">[&nbsp;TEXT_TY_Mutable&nbsp;txt;</span></span>
<span class="tr"><span class="th" id="line176">176</span><span class="td">&nbsp;if&nbsp;(txt--&gt;0&nbsp;&amp;&nbsp;BLK_BVBITMAP_LONGBLOCKMASK&nbsp;==&nbsp;0)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line177">177</span><span class="td">&nbsp;&nbsp;TEXT_TY_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line178">178</span><span class="td">&nbsp;&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line179">179</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line180">180</span><span class="td">&nbsp;return&nbsp;2;&nbsp;!&nbsp;Tell&nbsp;BlockValue&nbsp;there&#39;s&nbsp;a&nbsp;long&nbsp;block&nbsp;pointer</span></span>
<span class="tr"><span class="th" id="line181">181</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-casting">Casting.</h3><p><p> In general computing, &quot;casting&quot; is the process of translating data in one type into semantically equivalent data in another: the only interesting cast here is that a snippet can be turned into a text.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line189">189</span><span class="td">[&nbsp;TEXT_TY_Cast&nbsp;to_txt&nbsp;from_kind&nbsp;from_value;</span></span>
<span class="tr"><span class="th" id="line190">190</span><span class="td">&nbsp;if&nbsp;(from_kind&nbsp;==&nbsp;TEXT_TY)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line191">191</span><span class="td">&nbsp;&nbsp;BlkValueCopy(to_txt,&nbsp;from_value);</span></span>
<span class="tr"><span class="th" id="line192">192</span><span class="td">&nbsp;}&nbsp;else&nbsp;if&nbsp;(from_kind&nbsp;==&nbsp;SNIPPET_TY)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line193">193</span><span class="td">&nbsp;&nbsp;TEXT_TY_Transmute(to_txt);</span></span>
<span class="tr"><span class="th" id="line194">194</span><span class="td">&nbsp;&nbsp;TEXT_TY_CastPrimitive(to_txt,&nbsp;true,&nbsp;from_value);</span></span>
<span class="tr"><span class="th" id="line195">195</span><span class="td">&nbsp;}&nbsp;else&nbsp;BlkValueError(&quot;impossible&nbsp;cast&nbsp;to&nbsp;text&quot;);</span></span>
<span class="tr"><span class="th" id="line196">196</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line197">197</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line198">198</span><span class="td">[&nbsp;SNIPPET_TY_to_TEXT_TY&nbsp;to_txt&nbsp;snippet;</span></span>
<span class="tr"><span class="th" id="line199">199</span><span class="td">&nbsp;return&nbsp;BlkValueCast(to_txt,&nbsp;SNIPPET_TY,&nbsp;snippet);</span></span>
<span class="tr"><span class="th" id="line200">200</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-data-conversion">Data Conversion.</h3><p><p> We use a single routine to handle two kinds of format translation: a packed I6 string into an unpacked text, or a snippet into an unpacked text.<p></p><p> In each case, what we do is simply to print out the value we have, but with the output stream set to memory rather than the screen. That gives us the character by character version, neatly laid out in an array, and all we have to do is to copy it into the text and add a null termination byte.<p></p><p> What complicates things is that the two virtual machines handle printing to memory quite differently, and that the original text has unpredictable length. We are going to try printing it into the array <span class="fixed">TEXT_TY_Buffers</span>, but what if the text is too big? Disastrously, the Z-machine simply writes on in memory, corrupting all subsequent arrays and almost certainly causing the story file to crash soon after. There is nothing we can do to predict or avoid this, or to repair the damage: this is why the Inform documentation warns users to be wary of using text with large strings in the Z-machine, and advises the use of Glulx instead. Glulx does handle overruns safely, and indeed allows us to dynamically allocate memory as necessary so that we can always avoid overruns entirely.<p></p><p> In either case, though, it&#39;s useful to have <span class="fixed"><a href="./Text.i6t.html#line230">TEXT_TY_BufferSize</a></span>, the size of the temporary buffer, large enough that it will never be overrun in ordinary use. This is controllable with the use option &quot;maximum indexed text length&quot;.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line229">229</span><span class="td">#ifndef&nbsp;TEXT_TY_BufferSize;</span></span>
<span class="tr"><span class="th" id="line230">230</span><span class="td">Constant&nbsp;TEXT_TY_BufferSize&nbsp;=&nbsp;512;</span></span>
<span class="tr"><span class="th" id="line231">231</span><span class="td">#endif;</span></span>
<span class="tr"><span class="th" id="line232">232</span><span class="td">Constant&nbsp;TEXT_TY_NoBuffers&nbsp;=&nbsp;2;</span></span>
<span class="tr"><span class="th" id="line233">233</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line234">234</span><span class="td">#ifdef&nbsp;TARGET_ZCODE;</span></span>
<span class="tr"><span class="th" id="line235">235</span><span class="td">Array&nbsp;TEXT_TY_Buffers&nbsp;-&gt;&nbsp;TEXT_TY_BufferSize*TEXT_TY_NoBuffers;&nbsp;!&nbsp;Where&nbsp;characters&nbsp;are&nbsp;bytes</span></span>
<span class="tr"><span class="th" id="line236">236</span><span class="td">#ifnot;</span></span>
<span class="tr"><span class="th" id="line237">237</span><span class="td">Array&nbsp;TEXT_TY_Buffers&nbsp;--&gt;&nbsp;(TEXT_TY_BufferSize+2)*TEXT_TY_NoBuffers;&nbsp;!&nbsp;Where&nbsp;characters&nbsp;are&nbsp;words</span></span>
<span class="tr"><span class="th" id="line238">238</span><span class="td">#endif;</span></span>
<span class="tr"><span class="th" id="line239">239</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line240">240</span><span class="td">Global&nbsp;RawBufferAddress&nbsp;=&nbsp;TEXT_TY_Buffers;</span></span>
<span class="tr"><span class="th" id="line241">241</span><span class="td">Global&nbsp;RawBufferSize&nbsp;=&nbsp;TEXT_TY_BufferSize;</span></span>
<span class="tr"><span class="th" id="line242">242</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line243">243</span><span class="td">Global&nbsp;TEXT_TY_CastPrimitiveNesting&nbsp;=&nbsp;0;</span></span>
</div><div class='text'>
<h3 id="#text-z-version">Z Version.</h3><p><p> The two versions of this routine, one for each virtual machine, are in all important respects the same, but there are enough fiddly differences that it&#39;s clearer to give two definitions, so:<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line251">251</span><span class="td">#ifdef&nbsp;TARGET_ZCODE;</span></span>
<span class="tr"><span class="th" id="line252">252</span><span class="td">[&nbsp;TEXT_TY_CastPrimitive&nbsp;to_txt&nbsp;from_snippet&nbsp;from_value&nbsp;&nbsp;len&nbsp;news&nbsp;buffer;</span></span>
<span class="tr"><span class="th" id="line253">253</span><span class="td">&nbsp;if&nbsp;(to_txt&nbsp;==&nbsp;0)&nbsp;BlkValueError(&quot;no&nbsp;destination&nbsp;for&nbsp;cast&quot;);</span></span>
<span class="tr"><span class="th" id="line254">254</span><span class="td">&nbsp;SuspendRTP();</span></span>
<span class="tr"><span class="th" id="line255">255</span><span class="td">&nbsp;buffer&nbsp;=&nbsp;RawBufferAddress&nbsp;+&nbsp;TEXT_TY_CastPrimitiveNesting*TEXT_TY_BufferSize;</span></span>
<span class="tr"><span class="th" id="line256">256</span><span class="td">&nbsp;TEXT_TY_CastPrimitiveNesting++;</span></span>
<span class="tr"><span class="th" id="line257">257</span><span class="td">&nbsp;if&nbsp;(TEXT_TY_CastPrimitiveNesting&nbsp;&gt;&nbsp;TEXT_TY_NoBuffers)</span></span>
<span class="tr"><span class="th" id="line258">258</span><span class="td">&nbsp;&nbsp;FlexError(&quot;ran&nbsp;out&nbsp;with&nbsp;too&nbsp;many&nbsp;simultaneous&nbsp;text&nbsp;conversions&quot;);</span></span>
<span class="tr"><span class="th" id="line259">259</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line260">260</span><span class="td">&nbsp;@push&nbsp;say__p;&nbsp;@push&nbsp;say__pc;</span></span>
<span class="tr"><span class="th" id="line261">261</span><span class="td">&nbsp;ClearParagraphing(6);</span></span>
<span class="tr"><span class="th" id="line262">262</span><span class="td">&nbsp;@output_stream&nbsp;3&nbsp;buffer;</span></span>
<span class="tr"><span class="th" id="line263">263</span><span class="td">&nbsp;if&nbsp;(from_value)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line264">264</span><span class="td">&nbsp;&nbsp;if&nbsp;(from_snippet)&nbsp;print&nbsp;(PrintSnippet)&nbsp;from_value;</span></span>
<span class="tr"><span class="th" id="line265">265</span><span class="td">&nbsp;&nbsp;else&nbsp;print&nbsp;(PrintI6Text)&nbsp;from_value;</span></span>
<span class="tr"><span class="th" id="line266">266</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line267">267</span><span class="td">&nbsp;@output_stream&nbsp;-3;</span></span>
<span class="tr"><span class="th" id="line268">268</span><span class="td">&nbsp;@pull&nbsp;say__pc;&nbsp;@pull&nbsp;say__p;</span></span>
<span class="tr"><span class="th" id="line269">269</span><span class="td">&nbsp;ResumeRTP();</span></span>
<span class="tr"><span class="th" id="line270">270</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line271">271</span><span class="td">&nbsp;len&nbsp;=&nbsp;buffer--&gt;0;</span></span>
<span class="tr"><span class="th" id="line272">272</span><span class="td">&nbsp;if&nbsp;(len&nbsp;&gt;&nbsp;RawBufferSize-1)&nbsp;len&nbsp;=&nbsp;RawBufferSize-1;</span></span>
<span class="tr"><span class="th" id="line273">273</span><span class="td">&nbsp;buffer-&gt;(len+2)&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line274">274</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line275">275</span><span class="td">&nbsp;TEXT_TY_CastPrimitiveNesting--;</span></span>
<span class="tr"><span class="th" id="line276">276</span><span class="td">&nbsp;BlkValueMassCopyFromArray(to_txt,&nbsp;buffer+2,&nbsp;1,&nbsp;len+1);</span></span>
<span class="tr"><span class="th" id="line277">277</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-glulx-version">Glulx Version.</h3><p><p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line282">282</span><span class="td">#ifnot;&nbsp;!&nbsp;TARGET_ZCODE</span></span>
<span class="tr"><span class="th" id="line283">283</span><span class="td">[&nbsp;TEXT_TY_CastPrimitive&nbsp;to_txt&nbsp;from_snippet&nbsp;from_value</span></span>
<span class="tr"><span class="th" id="line284">284</span><span class="td">&nbsp;len&nbsp;i&nbsp;stream&nbsp;saved_stream&nbsp;news&nbsp;buffer&nbsp;buffer_size&nbsp;memory_to_free&nbsp;results;</span></span>
<span class="tr"><span class="th" id="line285">285</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line286">286</span><span class="td">&nbsp;if&nbsp;(to_txt&nbsp;==&nbsp;0)&nbsp;BlkValueError(&quot;no&nbsp;destination&nbsp;for&nbsp;cast&quot;);</span></span>
<span class="tr"><span class="th" id="line287">287</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line288">288</span><span class="td">&nbsp;buffer_size&nbsp;=&nbsp;(TEXT_TY_BufferSize&nbsp;+&nbsp;2)*WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line289">289</span><span class="td">&nbsp;</span></span>
<span class="tr"><span class="th" id="line290">290</span><span class="td">&nbsp;RawBufferSize&nbsp;=&nbsp;TEXT_TY_BufferSize;</span></span>
<span class="tr"><span class="th" id="line291">291</span><span class="td">&nbsp;buffer&nbsp;=&nbsp;RawBufferAddress&nbsp;+&nbsp;TEXT_TY_CastPrimitiveNesting*buffer_size;</span></span>
<span class="tr"><span class="th" id="line292">292</span><span class="td">&nbsp;TEXT_TY_CastPrimitiveNesting++;</span></span>
<span class="tr"><span class="th" id="line293">293</span><span class="td">&nbsp;if&nbsp;(TEXT_TY_CastPrimitiveNesting&nbsp;&gt;&nbsp;TEXT_TY_NoBuffers)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line294">294</span><span class="td">&nbsp;&nbsp;buffer&nbsp;=&nbsp;VM_AllocateMemory(buffer_size);&nbsp;memory_to_free&nbsp;=&nbsp;buffer;</span></span>
<span class="tr"><span class="th" id="line295">295</span><span class="td">&nbsp;&nbsp;if&nbsp;(buffer&nbsp;==&nbsp;0)</span></span>
<span class="tr"><span class="th" id="line296">296</span><span class="td">&nbsp;&nbsp;&nbsp;FlexError(&quot;ran&nbsp;out&nbsp;with&nbsp;too&nbsp;many&nbsp;simultaneous&nbsp;text&nbsp;conversions&quot;);</span></span>
<span class="tr"><span class="th" id="line297">297</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line298">298</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line299">299</span><span class="td">&nbsp;if&nbsp;(unicode_gestalt_ok)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line300">300</span><span class="td">&nbsp;&nbsp;SuspendRTP();</span></span>
<span class="tr"><span class="th" id="line301">301</span><span class="td">&nbsp;&nbsp;.RetryWithLargerBuffer;</span></span>
<span class="tr"><span class="th" id="line302">302</span><span class="td">&nbsp;&nbsp;saved_stream&nbsp;=&nbsp;glk_stream_get_current();</span></span>
<span class="tr"><span class="th" id="line303">303</span><span class="td">&nbsp;&nbsp;stream&nbsp;=&nbsp;glk_stream_open_memory_uni(buffer,&nbsp;RawBufferSize,&nbsp;filemode_Write,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line304">304</span><span class="td">&nbsp;&nbsp;glk_stream_set_current(stream);</span></span>
<span class="tr"><span class="th" id="line305">305</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line306">306</span><span class="td">&nbsp;&nbsp;@push&nbsp;say__p;&nbsp;@push&nbsp;say__pc;</span></span>
<span class="tr"><span class="th" id="line307">307</span><span class="td">&nbsp;&nbsp;ClearParagraphing(7);</span></span>
<span class="tr"><span class="th" id="line308">308</span><span class="td">&nbsp;&nbsp;if&nbsp;(from_snippet)&nbsp;print&nbsp;(PrintSnippet)&nbsp;from_value;</span></span>
<span class="tr"><span class="th" id="line309">309</span><span class="td">&nbsp;&nbsp;else&nbsp;print&nbsp;(PrintI6Text)&nbsp;from_value;</span></span>
<span class="tr"><span class="th" id="line310">310</span><span class="td">&nbsp;&nbsp;@pull&nbsp;say__pc;&nbsp;@pull&nbsp;say__p;</span></span>
<span class="tr"><span class="th" id="line311">311</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line312">312</span><span class="td">&nbsp;&nbsp;results&nbsp;=&nbsp;buffer&nbsp;+&nbsp;buffer_size&nbsp;-&nbsp;2*WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line313">313</span><span class="td">&nbsp;&nbsp;glk_stream_close(stream,&nbsp;results);</span></span>
<span class="tr"><span class="th" id="line314">314</span><span class="td">&nbsp;&nbsp;if&nbsp;(saved_stream)&nbsp;glk_stream_set_current(saved_stream);</span></span>
<span class="tr"><span class="th" id="line315">315</span><span class="td">&nbsp;&nbsp;ResumeRTP();</span></span>
<span class="tr"><span class="th" id="line316">316</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line317">317</span><span class="td">&nbsp;&nbsp;len&nbsp;=&nbsp;results--&gt;1;</span></span>
<span class="tr"><span class="th" id="line318">318</span><span class="td">&nbsp;&nbsp;if&nbsp;(len&nbsp;&gt;&nbsp;RawBufferSize-1)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line319">319</span><span class="td">&nbsp;&nbsp;&nbsp;!&nbsp;Glulx&nbsp;had&nbsp;to&nbsp;truncate&nbsp;text&nbsp;output&nbsp;because&nbsp;the&nbsp;buffer&nbsp;ran&nbsp;out:</span></span>
<span class="tr"><span class="th" id="line320">320</span><span class="td">&nbsp;&nbsp;&nbsp;!&nbsp;len&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;characters&nbsp;which&nbsp;it&nbsp;tried&nbsp;to&nbsp;print</span></span>
<span class="tr"><span class="th" id="line321">321</span><span class="td">&nbsp;&nbsp;&nbsp;news&nbsp;=&nbsp;RawBufferSize;</span></span>
<span class="tr"><span class="th" id="line322">322</span><span class="td">&nbsp;&nbsp;&nbsp;while&nbsp;(news&nbsp;&lt;&nbsp;len)&nbsp;news=news*2;</span></span>
<span class="tr"><span class="th" id="line323">323</span><span class="td">&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;VM_AllocateMemory(news*WORDSIZE);</span></span>
<span class="tr"><span class="th" id="line324">324</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;~=&nbsp;0)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line325">325</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(memory_to_free)&nbsp;VM_FreeMemory(memory_to_free);</span></span>
<span class="tr"><span class="th" id="line326">326</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;memory_to_free&nbsp;=&nbsp;i;</span></span>
<span class="tr"><span class="th" id="line327">327</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;buffer&nbsp;=&nbsp;i;</span></span>
<span class="tr"><span class="th" id="line328">328</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;RawBufferSize&nbsp;=&nbsp;news;</span></span>
<span class="tr"><span class="th" id="line329">329</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;buffer_size&nbsp;=&nbsp;(RawBufferSize&nbsp;+&nbsp;2)*WORDSIZE;</span></span>
<span class="tr"><span class="th" id="line330">330</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;jump&nbsp;<a href="./Text.i6t.html#line301">RetryWithLargerBuffer</a>;</span></span>
<span class="tr"><span class="th" id="line331">331</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line332">332</span><span class="td">&nbsp;&nbsp;&nbsp;!&nbsp;Memory&nbsp;allocation&nbsp;refused:&nbsp;all&nbsp;we&nbsp;can&nbsp;do&nbsp;is&nbsp;to&nbsp;truncate&nbsp;the&nbsp;text</span></span>
<span class="tr"><span class="th" id="line333">333</span><span class="td">&nbsp;&nbsp;&nbsp;len&nbsp;=&nbsp;RawBufferSize-1;</span></span>
<span class="tr"><span class="th" id="line334">334</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line335">335</span><span class="td">&nbsp;&nbsp;buffer--&gt;(len)&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line336">336</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line337">337</span><span class="td">&nbsp;&nbsp;TEXT_TY_CastPrimitiveNesting--;</span></span>
<span class="tr"><span class="th" id="line338">338</span><span class="td">&nbsp;&nbsp;BlkValueMassCopyFromArray(to_txt,&nbsp;buffer,&nbsp;4,&nbsp;len+1);</span></span>
<span class="tr"><span class="th" id="line339">339</span><span class="td">&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line340">340</span><span class="td">&nbsp;&nbsp;RunTimeProblem(RTP_NOGLULXUNICODE);</span></span>
<span class="tr"><span class="th" id="line341">341</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line342">342</span><span class="td">&nbsp;if&nbsp;(memory_to_free)&nbsp;VM_FreeMemory(memory_to_free);</span></span>
<span class="tr"><span class="th" id="line343">343</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line344">344</span><span class="td">#endif;&nbsp;</span></span>
</div><div class='text'>
<h3 id="#text-comparison">Comparison.</h3><p><p> This is more or less <span class="fixed">strcmp</span>, the traditional C library routine for comparing strings, but it does pose a few interesting questions. The answers are:<p></p><p> (a) Two different unexpanded texts with substitutions are never equal, so &quot;[X]&quot; and &quot;[Y]&quot; aren&#39;t equal as texts even if X and Y are equal. (b) Otherwise we test the current value of the text as expanded, so &quot;[X]&quot; and &quot;17&quot; can be equal as texts if X is 17.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line356">356</span><span class="td">[&nbsp;TEXT_TY_Compare&nbsp;left_txt&nbsp;right_txt&nbsp;rv;</span></span>
<span class="tr"><span class="th" id="line357">357</span><span class="td">&nbsp;@push&nbsp;say__comp;</span></span>
<span class="tr"><span class="th" id="line358">358</span><span class="td">&nbsp;say__comp&nbsp;=&nbsp;true;</span></span>
<span class="tr"><span class="th" id="line359">359</span><span class="td">&nbsp;rv&nbsp;=&nbsp;TEXT_TY_Compare_Inner(left_txt,&nbsp;right_txt);</span></span>
<span class="tr"><span class="th" id="line360">360</span><span class="td">&nbsp;@pull&nbsp;say__comp;</span></span>
<span class="tr"><span class="th" id="line361">361</span><span class="td">&nbsp;return&nbsp;rv;</span></span>
<span class="tr"><span class="th" id="line362">362</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line363">363</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line364">364</span><span class="td">[&nbsp;TEXT_TY_Compare_Inner&nbsp;left_txt&nbsp;right_txt</span></span>
<span class="tr"><span class="th" id="line365">365</span><span class="td">&nbsp;pos&nbsp;ch1&nbsp;ch2&nbsp;capacity_left&nbsp;capacity_right&nbsp;fl&nbsp;fr&nbsp;cl&nbsp;cr&nbsp;cpl&nbsp;cpr;</span></span>
<span class="tr"><span class="th" id="line366">366</span><span class="td">&nbsp;if&nbsp;(left_txt--&gt;0&nbsp;&amp;&nbsp;BLK_BVBITMAP_LONGBLOCKMASK&nbsp;==&nbsp;0)&nbsp;fl&nbsp;=&nbsp;true;</span></span>
<span class="tr"><span class="th" id="line367">367</span><span class="td">&nbsp;if&nbsp;(right_txt--&gt;0&nbsp;&amp;&nbsp;BLK_BVBITMAP_LONGBLOCKMASK&nbsp;==&nbsp;0)&nbsp;fr&nbsp;=&nbsp;true;</span></span>
<span class="tr"><span class="th" id="line368">368</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line369">369</span><span class="td">&nbsp;if&nbsp;(fl&nbsp;&amp;&amp;&nbsp;fr)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line370">370</span><span class="td">&nbsp;&nbsp;if&nbsp;((left_txt--&gt;1&nbsp;ofclass&nbsp;String)&nbsp;&amp;&amp;&nbsp;(right_txt--&gt;1&nbsp;ofclass&nbsp;String))</span></span>
<span class="tr"><span class="th" id="line371">371</span><span class="td">&nbsp;&nbsp;&nbsp;return&nbsp;left_txt--&gt;1&nbsp;-&nbsp;right_txt--&gt;1;</span></span>
<span class="tr"><span class="th" id="line372">372</span><span class="td">&nbsp;&nbsp;if&nbsp;((left_txt--&gt;1&nbsp;ofclass&nbsp;Routine)&nbsp;&amp;&amp;&nbsp;(right_txt--&gt;1&nbsp;ofclass&nbsp;Routine))</span></span>
<span class="tr"><span class="th" id="line373">373</span><span class="td">&nbsp;&nbsp;&nbsp;return&nbsp;left_txt--&gt;1&nbsp;-&nbsp;right_txt--&gt;1;</span></span>
<span class="tr"><span class="th" id="line374">374</span><span class="td">&nbsp;&nbsp;cpl&nbsp;=&nbsp;left_txt--&gt;0;&nbsp;cl&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(left_txt);</span></span>
<span class="tr"><span class="th" id="line375">375</span><span class="td">&nbsp;&nbsp;cpr&nbsp;=&nbsp;right_txt--&gt;0;&nbsp;cr&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(right_txt);&nbsp;&nbsp;</span></span>
<span class="tr"><span class="th" id="line376">376</span><span class="td">&nbsp;}&nbsp;else&nbsp;if&nbsp;(fl)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line377">377</span><span class="td">&nbsp;&nbsp;cpl&nbsp;=&nbsp;left_txt--&gt;0;&nbsp;cl&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(left_txt);</span></span>
<span class="tr"><span class="th" id="line378">378</span><span class="td">&nbsp;}&nbsp;else&nbsp;if&nbsp;(fr)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line379">379</span><span class="td">&nbsp;&nbsp;cpr&nbsp;=&nbsp;right_txt--&gt;0;&nbsp;cr&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(right_txt);</span></span>
<span class="tr"><span class="th" id="line380">380</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line381">381</span><span class="td">&nbsp;if&nbsp;((cl)&nbsp;||&nbsp;(cr))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line382">382</span><span class="td">&nbsp;&nbsp;pos&nbsp;=&nbsp;TEXT_TY_Compare(left_txt,&nbsp;right_txt);</span></span>
<span class="tr"><span class="th" id="line383">383</span><span class="td">&nbsp;&nbsp;TEXT_TY_Untransmute(left_txt,&nbsp;cl,&nbsp;cpl);</span></span>
<span class="tr"><span class="th" id="line384">384</span><span class="td">&nbsp;&nbsp;TEXT_TY_Untransmute(right_txt,&nbsp;cr,&nbsp;cpr);</span></span>
<span class="tr"><span class="th" id="line385">385</span><span class="td">&nbsp;&nbsp;return&nbsp;pos;</span></span>
<span class="tr"><span class="th" id="line386">386</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line387">387</span><span class="td">&nbsp;capacity_left&nbsp;=&nbsp;BlkValueLBCapacity(left_txt);</span></span>
<span class="tr"><span class="th" id="line388">388</span><span class="td">&nbsp;capacity_right&nbsp;=&nbsp;BlkValueLBCapacity(right_txt);</span></span>
<span class="tr"><span class="th" id="line389">389</span><span class="td">&nbsp;for&nbsp;(pos=0:(pos&lt;capacity_left)&nbsp;&amp;&amp;&nbsp;(pos&lt;capacity_right):pos++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line390">390</span><span class="td">&nbsp;&nbsp;ch1&nbsp;=&nbsp;BlkValueRead(left_txt,&nbsp;pos);</span></span>
<span class="tr"><span class="th" id="line391">391</span><span class="td">&nbsp;&nbsp;ch2&nbsp;=&nbsp;BlkValueRead(right_txt,&nbsp;pos);</span></span>
<span class="tr"><span class="th" id="line392">392</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch1&nbsp;~=&nbsp;ch2)&nbsp;return&nbsp;ch1-ch2;</span></span>
<span class="tr"><span class="th" id="line393">393</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch1&nbsp;==&nbsp;0)&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line394">394</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line395">395</span><span class="td">&nbsp;if&nbsp;(pos&nbsp;==&nbsp;capacity_left)&nbsp;return&nbsp;-1;</span></span>
<span class="tr"><span class="th" id="line396">396</span><span class="td">&nbsp;return&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line397">397</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line398">398</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line399">399</span><span class="td">[&nbsp;TEXT_TY_Distinguish&nbsp;left_txt&nbsp;right_txt;</span></span>
<span class="tr"><span class="th" id="line400">400</span><span class="td">&nbsp;if&nbsp;(TEXT_TY_Compare(left_txt,&nbsp;right_txt)&nbsp;==&nbsp;0)&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line401">401</span><span class="td">&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line402">402</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-hashing">Hashing.</h3><p><p> This calculates a hash value for the string, using Bernstein&#39;s algorithm.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line408">408</span><span class="td">[&nbsp;TEXT_TY_Hash&nbsp;txt&nbsp;&nbsp;rv&nbsp;len&nbsp;i&nbsp;p&nbsp;cp;</span></span>
<span class="tr"><span class="th" id="line409">409</span><span class="td">&nbsp;cp&nbsp;=&nbsp;txt--&gt;0;&nbsp;p&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line410">410</span><span class="td">&nbsp;rv&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line411">411</span><span class="td">&nbsp;len&nbsp;=&nbsp;BlkValueLBCapacity(txt);</span></span>
<span class="tr"><span class="th" id="line412">412</span><span class="td">&nbsp;for&nbsp;(i=0:&nbsp;i&lt;len:&nbsp;i++)</span></span>
<span class="tr"><span class="th" id="line413">413</span><span class="td">&nbsp;&nbsp;rv&nbsp;=&nbsp;rv&nbsp;*&nbsp;33&nbsp;+&nbsp;BlkValueRead(txt,&nbsp;i);</span></span>
<span class="tr"><span class="th" id="line414">414</span><span class="td">&nbsp;TEXT_TY_Untransmute(txt,&nbsp;p,&nbsp;cp);</span></span>
<span class="tr"><span class="th" id="line415">415</span><span class="td">&nbsp;return&nbsp;rv;</span></span>
<span class="tr"><span class="th" id="line416">416</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-printing">Printing.</h3><p><p> Unicode is not the native character set on Glulx: it came along as a late addition to Glulx&#39;s specification. The deal is that we have to explicitly tell the Glk interface layer to perform certain operations in a Unicode way; if we simply perform <span class="fixed">print (char) ch;</span> then the character <span class="fixed">ch</span> will be printed in ZSCII rather than Unicode.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line426">426</span><span class="td">[&nbsp;TEXT_TY_Say&nbsp;txt&nbsp;&nbsp;ch&nbsp;i&nbsp;dsize;</span></span>
<span class="tr"><span class="th" id="line427">427</span><span class="td">&nbsp;if&nbsp;(txt==0)&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line428">428</span><span class="td">&nbsp;if&nbsp;(txt--&gt;0&nbsp;&amp;&nbsp;BLK_BVBITMAP_LONGBLOCKMASK&nbsp;==&nbsp;0)&nbsp;return&nbsp;PrintI6Text(txt--&gt;1);</span></span>
<span class="tr"><span class="th" id="line429">429</span><span class="td">&nbsp;dsize&nbsp;=&nbsp;BlkValueLBCapacity(txt);</span></span>
<span class="tr"><span class="th" id="line430">430</span><span class="td">&nbsp;for&nbsp;(i=0:&nbsp;i&lt;dsize:&nbsp;i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line431">431</span><span class="td">&nbsp;&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;i);</span></span>
<span class="tr"><span class="th" id="line432">432</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;0)&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line433">433</span><span class="td">&nbsp;&nbsp;#ifdef&nbsp;TARGET_ZCODE;</span></span>
<span class="tr"><span class="th" id="line434">434</span><span class="td">&nbsp;&nbsp;print&nbsp;(char)&nbsp;ch;</span></span>
<span class="tr"><span class="th" id="line435">435</span><span class="td">&nbsp;&nbsp;#ifnot;&nbsp;!&nbsp;TARGET_ZCODE</span></span>
<span class="tr"><span class="th" id="line436">436</span><span class="td">&nbsp;&nbsp;@streamunichar&nbsp;ch;</span></span>
<span class="tr"><span class="th" id="line437">437</span><span class="td">&nbsp;&nbsp;#endif;</span></span>
<span class="tr"><span class="th" id="line438">438</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line439">439</span><span class="td">&nbsp;if&nbsp;(i&nbsp;==&nbsp;0)&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line440">440</span><span class="td">&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line441">441</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-capitalised-printing">Capitalised printing.</h3><p><p> It turns out to be useful to have a variation on this:<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line447">447</span><span class="td">[&nbsp;TEXT_TY_Say_Capitalised&nbsp;txt&nbsp;mod&nbsp;rc;</span></span>
<span class="tr"><span class="th" id="line448">448</span><span class="td">&nbsp;mod&nbsp;=&nbsp;BlkValueCreate(TEXT_TY);</span></span>
<span class="tr"><span class="th" id="line449">449</span><span class="td">&nbsp;TEXT_TY_SubstitutedForm(mod,&nbsp;txt);</span></span>
<span class="tr"><span class="th" id="line450">450</span><span class="td">&nbsp;if&nbsp;(TEXT_TY_CharacterLength(mod)&nbsp;&gt;&nbsp;0)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line451">451</span><span class="td">&nbsp;&nbsp;BlkValueWrite(mod,&nbsp;0,&nbsp;CharToCase(BlkValueRead(mod,&nbsp;0),&nbsp;1));</span></span>
<span class="tr"><span class="th" id="line452">452</span><span class="td">&nbsp;&nbsp;TEXT_TY_Say(mod);</span></span>
<span class="tr"><span class="th" id="line453">453</span><span class="td">&nbsp;&nbsp;rc&nbsp;=&nbsp;true;</span></span>
<span class="tr"><span class="th" id="line454">454</span><span class="td">&nbsp;&nbsp;say__p&nbsp;=&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line455">455</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line456">456</span><span class="td">&nbsp;BlkValueFree(mod);</span></span>
<span class="tr"><span class="th" id="line457">457</span><span class="td">&nbsp;return&nbsp;rc;</span></span>
<span class="tr"><span class="th" id="line458">458</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-serialisation">Serialisation.</h3><p><p> Here we print a serialised form of a text which can later be used to reconstruct the original text. The printing is apparently to the screen, but in fact always takes place when the output stream is a file.<p></p><p> The format chosen is a letter &quot;S&quot; for string, then a comma-separated list of decimal character codes, ending with the null terminator, and followed by a semicolon: thus <span class="fixed">S65,66,67,0;</span> is the serialised form of the text &quot;ABC&quot;.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line470">470</span><span class="td">[&nbsp;TEXT_TY_WriteFile&nbsp;txt&nbsp;len&nbsp;pos&nbsp;ch&nbsp;p&nbsp;cp;</span></span>
<span class="tr"><span class="th" id="line471">471</span><span class="td">&nbsp;cp&nbsp;=&nbsp;txt--&gt;0;&nbsp;p&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line472">472</span><span class="td">&nbsp;len&nbsp;=&nbsp;BlkValueLBCapacity(txt);</span></span>
<span class="tr"><span class="th" id="line473">473</span><span class="td">&nbsp;print&nbsp;&quot;S&quot;;</span></span>
<span class="tr"><span class="th" id="line474">474</span><span class="td">&nbsp;for&nbsp;(pos=0:&nbsp;pos&lt;=len:&nbsp;pos++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line475">475</span><span class="td">&nbsp;&nbsp;if&nbsp;(pos&nbsp;==&nbsp;len)&nbsp;ch&nbsp;=&nbsp;0;&nbsp;else&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;pos);</span></span>
<span class="tr"><span class="th" id="line476">476</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;0)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line477">477</span><span class="td">&nbsp;&nbsp;&nbsp;print&nbsp;&quot;0;&quot;;&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line478">478</span><span class="td">&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line479">479</span><span class="td">&nbsp;&nbsp;&nbsp;print&nbsp;ch,&nbsp;&quot;,&quot;;</span></span>
<span class="tr"><span class="th" id="line480">480</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line481">481</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line482">482</span><span class="td">&nbsp;TEXT_TY_Untransmute(txt,&nbsp;p,&nbsp;cp);</span></span>
<span class="tr"><span class="th" id="line483">483</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-unserialisation">Unserialisation.</h3><p><p> If that&#39;s the word: the reverse process, in which we read a stream of characters from a file and reconstruct the text which gave rise to them.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line491">491</span><span class="td">[&nbsp;TEXT_TY_ReadFile&nbsp;txt&nbsp;auxf&nbsp;ch&nbsp;i&nbsp;v&nbsp;dg&nbsp;pos&nbsp;tsize&nbsp;p;</span></span>
<span class="tr"><span class="th" id="line492">492</span><span class="td">&nbsp;TEXT_TY_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line493">493</span><span class="td">&nbsp;tsize&nbsp;=&nbsp;BlkValueLBCapacity(txt);</span></span>
<span class="tr"><span class="th" id="line494">494</span><span class="td">&nbsp;while&nbsp;(ch&nbsp;~=&nbsp;32&nbsp;or&nbsp;9&nbsp;or&nbsp;10&nbsp;or&nbsp;13&nbsp;or&nbsp;0&nbsp;or&nbsp;-1)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line495">495</span><span class="td">&nbsp;&nbsp;ch&nbsp;=&nbsp;FileIO_GetC(auxf);</span></span>
<span class="tr"><span class="th" id="line496">496</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;&#39;,&#39;&nbsp;or&nbsp;&#39;;&#39;)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line497">497</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(pos+1&nbsp;&gt;=&nbsp;tsize)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line498">498</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(txt,&nbsp;2*pos)&nbsp;==&nbsp;false)&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line499">499</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;tsize&nbsp;=&nbsp;BlkValueLBCapacity(txt);</span></span>
<span class="tr"><span class="th" id="line500">500</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line501">501</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(txt,&nbsp;pos++,&nbsp;v);</span></span>
<span class="tr"><span class="th" id="line502">502</span><span class="td">&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line503">503</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;&#39;;&#39;)&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line504">504</span><span class="td">&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line505">505</span><span class="td">&nbsp;&nbsp;&nbsp;dg&nbsp;=&nbsp;ch&nbsp;-&nbsp;&#39;0&#39;;</span></span>
<span class="tr"><span class="th" id="line506">506</span><span class="td">&nbsp;&nbsp;&nbsp;v&nbsp;=&nbsp;v*10&nbsp;+&nbsp;dg;</span></span>
<span class="tr"><span class="th" id="line507">507</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line508">508</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line509">509</span><span class="td">&nbsp;BlkValueWrite(txt,&nbsp;pos,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line510">510</span><span class="td">&nbsp;return&nbsp;txt;</span></span>
<span class="tr"><span class="th" id="line511">511</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-substitution">Substitution.</h3><p><p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line516">516</span><span class="td">[&nbsp;TEXT_TY_SubstitutedForm&nbsp;to&nbsp;txt;</span></span>
<span class="tr"><span class="th" id="line517">517</span><span class="td">&nbsp;if&nbsp;(txt)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line518">518</span><span class="td">&nbsp;&nbsp;BlkValueCopy(to,&nbsp;txt);</span></span>
<span class="tr"><span class="th" id="line519">519</span><span class="td">&nbsp;&nbsp;TEXT_TY_Transmute(to);</span></span>
<span class="tr"><span class="th" id="line520">520</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line521">521</span><span class="td">&nbsp;return&nbsp;to;</span></span>
<span class="tr"><span class="th" id="line522">522</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line523">523</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line524">524</span><span class="td">[&nbsp;TEXT_TY_IsSubstituted&nbsp;txt;</span></span>
<span class="tr"><span class="th" id="line525">525</span><span class="td">&nbsp;if&nbsp;((txt)&nbsp;&amp;&amp;</span></span>
<span class="tr"><span class="th" id="line526">526</span><span class="td">&nbsp;&nbsp;(txt--&gt;0&nbsp;&amp;&nbsp;BLK_BVBITMAP_LONGBLOCKMASK&nbsp;==&nbsp;0)&nbsp;&amp;&amp;</span></span>
<span class="tr"><span class="th" id="line527">527</span><span class="td">&nbsp;&nbsp;(txt--&gt;1&nbsp;ofclass&nbsp;Routine))&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line528">528</span><span class="td">&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line529">529</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-perishability">Perishability.</h3><p><p> As noted above, a perishable constant is one which must be expanded before the values it refers to vanish from existence.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line536">536</span><span class="td">[&nbsp;TEXT_TY_ExpandIfPerishable&nbsp;to&nbsp;from;</span></span>
<span class="tr"><span class="th" id="line537">537</span><span class="td">&nbsp;if&nbsp;((from)&nbsp;&amp;&amp;&nbsp;(from--&gt;0&nbsp;==&nbsp;CONSTANT_PERISHABLE_TEXT_STORAGE))</span></span>
<span class="tr"><span class="th" id="line538">538</span><span class="td">&nbsp;&nbsp;return&nbsp;TEXT_TY_SubstitutedForm(to,&nbsp;from);</span></span>
<span class="tr"><span class="th" id="line539">539</span><span class="td">&nbsp;return&nbsp;from;</span></span>
<span class="tr"><span class="th" id="line540">540</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-recognition-only-gpr">Recognition-only-GPR.</h3><p><p> An I6 general parsing routine to look at words from the position marker <span class="fixed"><a href="./Output.i6t.html#line283">wn</a></span> in the player&#39;s command to see if they match the contents of thetext <span class="fixed">txt</span>, returning either <span class="fixed"><a href="./Definitions.i6t.html#line542">GPR_PREPOSITION</a></span> or <span class="fixed"><a href="./Definitions.i6t.html#line541">GPR_FAIL</a></span><br> according to whether a match could be made. This is used when the an object&#39;s name is set to include one of its properties, and the property in question is a text: &quot;A flowerpot is a kind of thing. A flowerpot has a text called pattern. Understand the pattern property as describing a flowerpot.&quot; When the player types EXAMINE STRIPED FLOWERPOT, and there is a flowerpot in scope, the following routine is called to test whether its pattern property &ndash; a text &ndash; matches any words at the position STRIPED FLOWERPOT. Assuming a pot does indeed have the pattern &quot;striped&quot;, the routine advances <span class="fixed"><a href="./Output.i6t.html#line283">wn</a></span> by 1 and returns <span class="fixed"><a href="./Definitions.i6t.html#line542">GPR_PREPOSITION</a></span> to indicate a match.<p></p><p> This kind of GPR is called a &quot;recognition-only-GPR&quot;, because it only recognises an existing value: it doesn&#39;t parse a new one.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line561">561</span><span class="td">[&nbsp;TEXT_TY_ROGPR&nbsp;txt&nbsp;p&nbsp;cp&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line562">562</span><span class="td">&nbsp;if&nbsp;(txt&nbsp;==&nbsp;0)&nbsp;return&nbsp;GPR_FAIL;</span></span>
<span class="tr"><span class="th" id="line563">563</span><span class="td">&nbsp;cp&nbsp;=&nbsp;txt--&gt;0;&nbsp;p&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line564">564</span><span class="td">&nbsp;r&nbsp;=&nbsp;TEXT_TY_ROGPRI(txt);</span></span>
<span class="tr"><span class="th" id="line565">565</span><span class="td">&nbsp;TEXT_TY_Untransmute(txt,&nbsp;p,&nbsp;cp);</span></span>
<span class="tr"><span class="th" id="line566">566</span><span class="td">&nbsp;return&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line567">567</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line568">568</span><span class="td">[&nbsp;TEXT_TY_ROGPRI&nbsp;txt</span></span>
<span class="tr"><span class="th" id="line569">569</span><span class="td">&nbsp;pos&nbsp;len&nbsp;wa&nbsp;wl&nbsp;wpos&nbsp;bdm&nbsp;ch&nbsp;own;</span></span>
<span class="tr"><span class="th" id="line570">570</span><span class="td">&nbsp;bdm&nbsp;=&nbsp;true;&nbsp;own&nbsp;=&nbsp;wn;</span></span>
<span class="tr"><span class="th" id="line571">571</span><span class="td">&nbsp;len&nbsp;=&nbsp;BlkValueLBCapacity(txt);</span></span>
<span class="tr"><span class="th" id="line572">572</span><span class="td">&nbsp;for&nbsp;(pos=0:&nbsp;pos&lt;=len:&nbsp;pos++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line573">573</span><span class="td">&nbsp;&nbsp;if&nbsp;(pos&nbsp;==&nbsp;len)&nbsp;ch&nbsp;=&nbsp;0;&nbsp;else&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;pos);</span></span>
<span class="tr"><span class="th" id="line574">574</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;32&nbsp;or&nbsp;9&nbsp;or&nbsp;10&nbsp;or&nbsp;0)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line575">575</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(bdm)&nbsp;continue;</span></span>
<span class="tr"><span class="th" id="line576">576</span><span class="td">&nbsp;&nbsp;&nbsp;bdm&nbsp;=&nbsp;true;</span></span>
<span class="tr"><span class="th" id="line577">577</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(wpos&nbsp;~=&nbsp;wl)&nbsp;return&nbsp;GPR_FAIL;</span></span>
<span class="tr"><span class="th" id="line578">578</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;0)&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line579">579</span><span class="td">&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line580">580</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(bdm)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line581">581</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;bdm&nbsp;=&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line582">582</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(NextWordStopped()&nbsp;==&nbsp;-1)&nbsp;return&nbsp;GPR_FAIL;</span></span>
<span class="tr"><span class="th" id="line583">583</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;wa&nbsp;=&nbsp;WordAddress(wn-1);</span></span>
<span class="tr"><span class="th" id="line584">584</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;wl&nbsp;=&nbsp;WordLength(wn-1);</span></span>
<span class="tr"><span class="th" id="line585">585</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;wpos&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line586">586</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line587">587</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(wa-&gt;wpos&nbsp;~=&nbsp;ch&nbsp;or&nbsp;TEXT_TY_RevCase(ch))&nbsp;return&nbsp;GPR_FAIL;</span></span>
<span class="tr"><span class="th" id="line588">588</span><span class="td">&nbsp;&nbsp;&nbsp;wpos++;</span></span>
<span class="tr"><span class="th" id="line589">589</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line590">590</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line591">591</span><span class="td">&nbsp;if&nbsp;(wn&nbsp;==&nbsp;own)&nbsp;return&nbsp;GPR_FAIL;&nbsp;!&nbsp;Progress&nbsp;must&nbsp;be&nbsp;made&nbsp;to&nbsp;avoid&nbsp;looping</span></span>
<span class="tr"><span class="th" id="line592">592</span><span class="td">&nbsp;return&nbsp;GPR_PREPOSITION;</span></span>
<span class="tr"><span class="th" id="line593">593</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-blobs">Blobs.</h3><p><p> That completes the compulsory services required for this KOV to function: from here on, the remaining routines provide definitions of text-related phrases in the Standard Rules.<p></p><p> What are the basic operations of text-handling? Clearly we want to be able to search, and replace, but that is left for the segment <a href="./RegExp.i6t.html">RegExp.i6t</a> to handle. More basically we would like to be able to read and write characters from the text. But texts in I7 tend to be of natural language, rather than containing arbitrary material &ndash; that&#39;s indeed why we call them texts rather than strings. This means they are likely to be punctuated sequences of words, divided up perhaps into sentences and even paragraphs.<p></p><p> So we provide facilities which regard a text as being an array of &quot;blobs&quot;, where a &quot;blob&quot; is a unit of text. The user can choose whether to see it as an array of characters, or words (of three different sorts: see the Inform documentation for details), or paragraphs, or lines. <p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line614">614</span><span class="td">Constant&nbsp;CHR_BLOB&nbsp;=&nbsp;1;&nbsp;!&nbsp;Construe&nbsp;as&nbsp;an&nbsp;array&nbsp;of&nbsp;characters</span></span>
<span class="tr"><span class="th" id="line615">615</span><span class="td">Constant&nbsp;WORD_BLOB&nbsp;=&nbsp;2;&nbsp;!&nbsp;Of&nbsp;words</span></span>
<span class="tr"><span class="th" id="line616">616</span><span class="td">Constant&nbsp;PWORD_BLOB&nbsp;=&nbsp;3;&nbsp;!&nbsp;Of&nbsp;punctuated&nbsp;words</span></span>
<span class="tr"><span class="th" id="line617">617</span><span class="td">Constant&nbsp;UWORD_BLOB&nbsp;=&nbsp;4;&nbsp;!&nbsp;Of&nbsp;unpunctuated&nbsp;words</span></span>
<span class="tr"><span class="th" id="line618">618</span><span class="td">Constant&nbsp;PARA_BLOB&nbsp;=&nbsp;5;&nbsp;!&nbsp;Of&nbsp;paragraphs</span></span>
<span class="tr"><span class="th" id="line619">619</span><span class="td">Constant&nbsp;LINE_BLOB&nbsp;=&nbsp;6;&nbsp;!&nbsp;Of&nbsp;lines</span></span>
<span class="tr"><span class="th" id="line620">620</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line621">621</span><span class="td">Constant&nbsp;REGEXP_BLOB&nbsp;=&nbsp;7;&nbsp;!&nbsp;Not&nbsp;a&nbsp;blob&nbsp;type&nbsp;as&nbsp;such,&nbsp;but&nbsp;needed&nbsp;as&nbsp;a&nbsp;distinct&nbsp;value</span></span>
</div><div class='text'>
<h3 id="#text-blob-access">Blob Access.</h3><p><p> The following routine runs a small finite-state-machine to count the number of blobs in a text, using any of the above blob types (except <span class="fixed"><a href="./Text.i6t.html#line621">REGEXP_BLOB</a></span>, which is used for other purposes). If the optional arguments <span class="fixed">ctxt</span> and <span class="fixed">wanted</span> are supplied, it also copies the text of blob number <span class="fixed">wanted</span> (counting upwards from 1 at the start of the text) into the text <span class="fixed">ctxt</span>. If the further optional argument <span class="fixed">rtxt</span> is supplied, then <span class="fixed">ctxt</span> is instead written with the original text <span class="fixed">txt</span> as it would read if the blob in question were replaced with the text in <span class="fixed">rtxt</span>.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line634">634</span><span class="td">Constant&nbsp;WS_BRM&nbsp;=&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line635">635</span><span class="td">Constant&nbsp;SKIPPED_BRM&nbsp;=&nbsp;2;</span></span>
<span class="tr"><span class="th" id="line636">636</span><span class="td">Constant&nbsp;ACCEPTED_BRM&nbsp;=&nbsp;3;</span></span>
<span class="tr"><span class="th" id="line637">637</span><span class="td">Constant&nbsp;ACCEPTEDP_BRM&nbsp;=&nbsp;4;</span></span>
<span class="tr"><span class="th" id="line638">638</span><span class="td">Constant&nbsp;ACCEPTEDN_BRM&nbsp;=&nbsp;5;</span></span>
<span class="tr"><span class="th" id="line639">639</span><span class="td">Constant&nbsp;ACCEPTEDPN_BRM&nbsp;=&nbsp;6;</span></span>
<span class="tr"><span class="th" id="line640">640</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line641">641</span><span class="td">[&nbsp;TEXT_TY_BlobAccess&nbsp;txt&nbsp;blobtype&nbsp;ctxt&nbsp;wanted&nbsp;rtxt</span></span>
<span class="tr"><span class="th" id="line642">642</span><span class="td">&nbsp;p1&nbsp;p2&nbsp;cp1&nbsp;cp2&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line643">643</span><span class="td">&nbsp;if&nbsp;(txt==0)&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line644">644</span><span class="td">&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;CHR_BLOB)&nbsp;return&nbsp;TEXT_TY_CharacterLength(txt);</span></span>
<span class="tr"><span class="th" id="line645">645</span><span class="td">&nbsp;cp1&nbsp;=&nbsp;txt--&gt;0;&nbsp;p1&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line646">646</span><span class="td">&nbsp;cp2&nbsp;=&nbsp;rtxt--&gt;0;&nbsp;p2&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(rtxt);</span></span>
<span class="tr"><span class="th" id="line647">647</span><span class="td">&nbsp;TEXT_TY_Transmute(ctxt);</span></span>
<span class="tr"><span class="th" id="line648">648</span><span class="td">&nbsp;r&nbsp;=&nbsp;TEXT_TY_BlobAccessI(txt,&nbsp;blobtype,&nbsp;ctxt,&nbsp;wanted,&nbsp;rtxt);</span></span>
<span class="tr"><span class="th" id="line649">649</span><span class="td">&nbsp;TEXT_TY_Untransmute(txt,&nbsp;p1,&nbsp;cp1);</span></span>
<span class="tr"><span class="th" id="line650">650</span><span class="td">&nbsp;TEXT_TY_Untransmute(rtxt,&nbsp;p2,&nbsp;cp2);</span></span>
<span class="tr"><span class="th" id="line651">651</span><span class="td">&nbsp;return&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line652">652</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line653">653</span><span class="td">[&nbsp;TEXT_TY_BlobAccessI&nbsp;txt&nbsp;blobtype&nbsp;ctxt&nbsp;wanted&nbsp;rtxt</span></span>
<span class="tr"><span class="th" id="line654">654</span><span class="td">&nbsp;brm&nbsp;oldbrm&nbsp;ch&nbsp;i&nbsp;dsize&nbsp;csize&nbsp;blobcount&nbsp;gp&nbsp;cl&nbsp;j;</span></span>
<span class="tr"><span class="th" id="line655">655</span><span class="td">&nbsp;dsize&nbsp;=&nbsp;BlkValueLBCapacity(txt);</span></span>
<span class="tr"><span class="th" id="line656">656</span><span class="td">&nbsp;if&nbsp;(ctxt)&nbsp;csize&nbsp;=&nbsp;BlkValueLBCapacity(ctxt);</span></span>
<span class="tr"><span class="th" id="line657">657</span><span class="td">&nbsp;else&nbsp;if&nbsp;(rtxt)&nbsp;&quot;***&nbsp;rtxt&nbsp;without&nbsp;ctxt&nbsp;***&quot;;</span></span>
<span class="tr"><span class="th" id="line658">658</span><span class="td">&nbsp;brm&nbsp;=&nbsp;WS_BRM;</span></span>
<span class="tr"><span class="th" id="line659">659</span><span class="td">&nbsp;for&nbsp;(i=0:i&lt;dsize:i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line660">660</span><span class="td">&nbsp;&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;i);</span></span>
<span class="tr"><span class="th" id="line661">661</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;0)&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line662">662</span><span class="td">&nbsp;&nbsp;oldbrm&nbsp;=&nbsp;brm;</span></span>
<span class="tr"><span class="th" id="line663">663</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;10&nbsp;or&nbsp;13&nbsp;or&nbsp;32&nbsp;or&nbsp;9)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line664">664</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(oldbrm&nbsp;~=&nbsp;WS_BRM)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line665">665</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;gp&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line666">666</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(j=i:j&lt;dsize:j++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line667">667</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;j);</span></span>
<span class="tr"><span class="th" id="line668">668</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;0)&nbsp;{&nbsp;brm&nbsp;=&nbsp;WS_BRM;&nbsp;break;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line669">669</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;10&nbsp;or&nbsp;13)&nbsp;{&nbsp;gp++;&nbsp;continue;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line670">670</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ch&nbsp;~=&nbsp;32&nbsp;or&nbsp;9)&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line671">671</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line672">672</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;i);</span></span>
<span class="tr"><span class="th" id="line673">673</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(j&nbsp;==&nbsp;dsize)&nbsp;brm&nbsp;=&nbsp;WS_BRM;</span></span>
<span class="tr"><span class="th" id="line674">674</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(blobtype)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line675">675</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PARA_BLOB:&nbsp;if&nbsp;(gp&nbsp;&gt;=&nbsp;2)&nbsp;brm&nbsp;=&nbsp;WS_BRM;</span></span>
<span class="tr"><span class="th" id="line676">676</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LINE_BLOB:&nbsp;if&nbsp;(gp&nbsp;&gt;=&nbsp;1)&nbsp;brm&nbsp;=&nbsp;WS_BRM;</span></span>
<span class="tr"><span class="th" id="line677">677</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;brm&nbsp;=&nbsp;WS_BRM;</span></span>
<span class="tr"><span class="th" id="line678">678</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line679">679</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line680">680</span><span class="td">&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line681">681</span><span class="td">&nbsp;&nbsp;&nbsp;gp&nbsp;=&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line682">682</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;((blobtype&nbsp;==&nbsp;WORD_BLOB&nbsp;or&nbsp;PWORD_BLOB&nbsp;or&nbsp;UWORD_BLOB)&nbsp;&amp;&amp;</span></span>
<span class="tr"><span class="th" id="line683">683</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;(ch&nbsp;==&nbsp;&#39;.&#39;&nbsp;or&nbsp;&#39;,&#39;&nbsp;or&nbsp;&#39;!&#39;&nbsp;or&nbsp;&#39;?&#39;</span></span>
<span class="tr"><span class="th" id="line684">684</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&#39;-&#39;&nbsp;or&nbsp;&#39;/&#39;&nbsp;or&nbsp;&#39;&quot;&#39;&nbsp;or&nbsp;&#39;:&#39;&nbsp;or&nbsp;&#39;;&#39;</span></span>
<span class="tr"><span class="th" id="line685">685</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&#39;(&#39;&nbsp;or&nbsp;&#39;)&#39;&nbsp;or&nbsp;&#39;[&#39;&nbsp;or&nbsp;&#39;]&#39;&nbsp;or&nbsp;&#39;{&#39;&nbsp;or&nbsp;&#39;}&#39;))</span></span>
<span class="tr"><span class="th" id="line686">686</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;gp&nbsp;=&nbsp;true;</span></span>
<span class="tr"><span class="th" id="line687">687</span><span class="td">&nbsp;&nbsp;&nbsp;switch&nbsp;(oldbrm)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line688">688</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;WS_BRM:</span></span>
<span class="tr"><span class="th" id="line689">689</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brm&nbsp;=&nbsp;ACCEPTED_BRM;</span></span>
<span class="tr"><span class="th" id="line690">690</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;WORD_BLOB)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line691">691</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gp)&nbsp;brm&nbsp;=&nbsp;SKIPPED_BRM;</span></span>
<span class="tr"><span class="th" id="line692">692</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line693">693</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;PWORD_BLOB)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line694">694</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gp)&nbsp;brm&nbsp;=&nbsp;ACCEPTEDP_BRM;</span></span>
<span class="tr"><span class="th" id="line695">695</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line696">696</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;SKIPPED_BRM:</span></span>
<span class="tr"><span class="th" id="line697">697</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;WORD_BLOB)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line698">698</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gp&nbsp;==&nbsp;false)&nbsp;brm&nbsp;=&nbsp;ACCEPTED_BRM;</span></span>
<span class="tr"><span class="th" id="line699">699</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line700">700</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;ACCEPTED_BRM:</span></span>
<span class="tr"><span class="th" id="line701">701</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;WORD_BLOB)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line702">702</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gp)&nbsp;brm&nbsp;=&nbsp;SKIPPED_BRM;</span></span>
<span class="tr"><span class="th" id="line703">703</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line704">704</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;PWORD_BLOB)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line705">705</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gp)&nbsp;brm&nbsp;=&nbsp;ACCEPTEDP_BRM;</span></span>
<span class="tr"><span class="th" id="line706">706</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line707">707</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;ACCEPTEDP_BRM:</span></span>
<span class="tr"><span class="th" id="line708">708</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;PWORD_BLOB)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line709">709</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gp&nbsp;==&nbsp;false)&nbsp;brm&nbsp;=&nbsp;ACCEPTED_BRM;</span></span>
<span class="tr"><span class="th" id="line710">710</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line711">711</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((ch&nbsp;==&nbsp;BlkValueRead(txt,&nbsp;i-1))&nbsp;&amp;&amp;</span></span>
<span class="tr"><span class="th" id="line712">712</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ch&nbsp;==&nbsp;&#39;-&#39;&nbsp;or&nbsp;&#39;.&#39;))&nbsp;blobcount--;</span></span>
<span class="tr"><span class="th" id="line713">713</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blobcount++;</span></span>
<span class="tr"><span class="th" id="line714">714</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line715">715</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line716">716</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;ACCEPTEDN_BRM:</span></span>
<span class="tr"><span class="th" id="line717">717</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;WORD_BLOB)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line718">718</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gp)&nbsp;brm&nbsp;=&nbsp;SKIPPED_BRM;</span></span>
<span class="tr"><span class="th" id="line719">719</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line720">720</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;PWORD_BLOB)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line721">721</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gp)&nbsp;brm&nbsp;=&nbsp;ACCEPTEDP_BRM;</span></span>
<span class="tr"><span class="th" id="line722">722</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line723">723</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;ACCEPTEDPN_BRM:</span></span>
<span class="tr"><span class="th" id="line724">724</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;PWORD_BLOB)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line725">725</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gp&nbsp;==&nbsp;false)&nbsp;brm&nbsp;=&nbsp;ACCEPTED_BRM;</span></span>
<span class="tr"><span class="th" id="line726">726</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line727">727</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((ch&nbsp;==&nbsp;BlkValueRead(txt,&nbsp;i-1))&nbsp;&amp;&amp;</span></span>
<span class="tr"><span class="th" id="line728">728</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ch&nbsp;==&nbsp;&#39;-&#39;&nbsp;or&nbsp;&#39;.&#39;))&nbsp;blobcount--;</span></span>
<span class="tr"><span class="th" id="line729">729</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blobcount++;</span></span>
<span class="tr"><span class="th" id="line730">730</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line731">731</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line732">732</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line733">733</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line734">734</span><span class="td">&nbsp;&nbsp;if&nbsp;(brm&nbsp;==&nbsp;ACCEPTED_BRM&nbsp;or&nbsp;ACCEPTEDP_BRM)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line735">735</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(oldbrm&nbsp;~=&nbsp;brm)&nbsp;blobcount++;</span></span>
<span class="tr"><span class="th" id="line736">736</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;((ctxt)&nbsp;&amp;&amp;&nbsp;(blobcount&nbsp;==&nbsp;wanted))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line737">737</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rtxt)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line738">738</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;cl,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line739">739</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEXT_TY_Concatenate(ctxt,&nbsp;rtxt,&nbsp;CHR_BLOB);</span></span>
<span class="tr"><span class="th" id="line740">740</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;csize&nbsp;=&nbsp;BlkValueLBCapacity(ctxt);</span></span>
<span class="tr"><span class="th" id="line741">741</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;=&nbsp;TEXT_TY_CharacterLength(ctxt);</span></span>
<span class="tr"><span class="th" id="line742">742</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(brm&nbsp;==&nbsp;ACCEPTED_BRM)&nbsp;brm&nbsp;=&nbsp;ACCEPTEDN_BRM;</span></span>
<span class="tr"><span class="th" id="line743">743</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(brm&nbsp;==&nbsp;ACCEPTEDP_BRM)&nbsp;brm&nbsp;=&nbsp;ACCEPTEDPN_BRM;</span></span>
<span class="tr"><span class="th" id="line744">744</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line745">745</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cl+1&nbsp;&gt;=&nbsp;csize)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line746">746</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(ctxt,&nbsp;2*cl)&nbsp;==&nbsp;false)&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line747">747</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;csize&nbsp;=&nbsp;BlkValueLBCapacity(ctxt);</span></span>
<span class="tr"><span class="th" id="line748">748</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line749">749</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;cl++,&nbsp;ch);</span></span>
<span class="tr"><span class="th" id="line750">750</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line751">751</span><span class="td">&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line752">752</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(rtxt)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line753">753</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cl+1&nbsp;&gt;=&nbsp;csize)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line754">754</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(ctxt,&nbsp;2*cl)&nbsp;==&nbsp;false)&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line755">755</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;csize&nbsp;=&nbsp;BlkValueLBCapacity(ctxt);</span></span>
<span class="tr"><span class="th" id="line756">756</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line757">757</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;cl++,&nbsp;ch);</span></span>
<span class="tr"><span class="th" id="line758">758</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line759">759</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line760">760</span><span class="td">&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line761">761</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;((rtxt)&nbsp;&amp;&amp;&nbsp;(brm&nbsp;~=&nbsp;ACCEPTEDN_BRM&nbsp;or&nbsp;ACCEPTEDPN_BRM))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line762">762</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cl+1&nbsp;&gt;=&nbsp;csize)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line763">763</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(ctxt,&nbsp;2*cl)&nbsp;==&nbsp;false)&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line764">764</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;csize&nbsp;=&nbsp;BlkValueLBCapacity(ctxt);</span></span>
<span class="tr"><span class="th" id="line765">765</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line766">766</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;cl++,&nbsp;ch);</span></span>
<span class="tr"><span class="th" id="line767">767</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line768">768</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line769">769</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line770">770</span><span class="td">&nbsp;if&nbsp;(ctxt)&nbsp;BlkValueWrite(ctxt,&nbsp;cl++,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line771">771</span><span class="td">&nbsp;return&nbsp;blobcount;</span></span>
<span class="tr"><span class="th" id="line772">772</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-get-blob">Get Blob.</h3><p><p> The front end which uses the above routine to read a blob. (Note that, for efficiency&#39;s sake, we read characters more directly.)<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line779">779</span><span class="td">[&nbsp;TEXT_TY_GetBlob&nbsp;ctxt&nbsp;txt&nbsp;wanted&nbsp;blobtype;</span></span>
<span class="tr"><span class="th" id="line780">780</span><span class="td">&nbsp;if&nbsp;(txt==0)&nbsp;return;</span></span>
<span class="tr"><span class="th" id="line781">781</span><span class="td">&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;CHR_BLOB)&nbsp;return&nbsp;TEXT_TY_GetCharacter(ctxt,&nbsp;txt,&nbsp;wanted);</span></span>
<span class="tr"><span class="th" id="line782">782</span><span class="td">&nbsp;TEXT_TY_BlobAccess(txt,&nbsp;blobtype,&nbsp;ctxt,&nbsp;wanted);</span></span>
<span class="tr"><span class="th" id="line783">783</span><span class="td">&nbsp;return&nbsp;ctxt;</span></span>
<span class="tr"><span class="th" id="line784">784</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-replace-blob">Replace Blob.</h3><p><p> The front end which uses the above routine to replace a blob. (Once again, characters are handled directly to avoid incurring all that overhead.)<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line791">791</span><span class="td">[&nbsp;TEXT_TY_ReplaceBlob&nbsp;blobtype&nbsp;txt&nbsp;wanted&nbsp;rtxt&nbsp;ctxt&nbsp;ilen&nbsp;rlen&nbsp;i&nbsp;p&nbsp;cp;</span></span>
<span class="tr"><span class="th" id="line792">792</span><span class="td">&nbsp;TEXT_TY_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line793">793</span><span class="td">&nbsp;cp&nbsp;=&nbsp;rtxt--&gt;0;&nbsp;p&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(rtxt);</span></span>
<span class="tr"><span class="th" id="line794">794</span><span class="td">&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;CHR_BLOB)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line795">795</span><span class="td">&nbsp;&nbsp;ilen&nbsp;=&nbsp;TEXT_TY_CharacterLength(txt);</span></span>
<span class="tr"><span class="th" id="line796">796</span><span class="td">&nbsp;&nbsp;rlen&nbsp;=&nbsp;TEXT_TY_CharacterLength(rtxt);</span></span>
<span class="tr"><span class="th" id="line797">797</span><span class="td">&nbsp;&nbsp;wanted--;</span></span>
<span class="tr"><span class="th" id="line798">798</span><span class="td">&nbsp;&nbsp;if&nbsp;((wanted&nbsp;&gt;=&nbsp;0)&nbsp;&amp;&amp;&nbsp;(wanted&lt;ilen))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line799">799</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(rlen&nbsp;==&nbsp;1)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line800">800</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(txt,&nbsp;wanted,&nbsp;BlkValueRead(rtxt,&nbsp;0));</span></span>
<span class="tr"><span class="th" id="line801">801</span><span class="td">&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line802">802</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;ctxt&nbsp;=&nbsp;BlkValueCreate(TEXT_TY);</span></span>
<span class="tr"><span class="th" id="line803">803</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;TEXT_TY_Transmute(ctxt);</span></span>
<span class="tr"><span class="th" id="line804">804</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(ctxt,&nbsp;ilen+rlen+1))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line805">805</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0:i&lt;wanted:i++)</span></span>
<span class="tr"><span class="th" id="line806">806</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;i,&nbsp;BlkValueRead(txt,&nbsp;i));</span></span>
<span class="tr"><span class="th" id="line807">807</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=0:i&lt;rlen:i++)</span></span>
<span class="tr"><span class="th" id="line808">808</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;wanted+i,&nbsp;BlkValueRead(rtxt,&nbsp;i));</span></span>
<span class="tr"><span class="th" id="line809">809</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(i=wanted+1:i&lt;ilen:i++)</span></span>
<span class="tr"><span class="th" id="line810">810</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;rlen+i-1,&nbsp;BlkValueRead(txt,&nbsp;i));</span></span>
<span class="tr"><span class="th" id="line811">811</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;rlen+ilen,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line812">812</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueCopy(txt,&nbsp;ctxt);</span></span>
<span class="tr"><span class="th" id="line813">813</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line814">814</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueFree(ctxt);</span></span>
<span class="tr"><span class="th" id="line815">815</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line816">816</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line817">817</span><span class="td">&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line818">818</span><span class="td">&nbsp;&nbsp;ctxt&nbsp;=&nbsp;BlkValueCreate(TEXT_TY);</span></span>
<span class="tr"><span class="th" id="line819">819</span><span class="td">&nbsp;&nbsp;TEXT_TY_BlobAccess(txt,&nbsp;blobtype,&nbsp;ctxt,&nbsp;wanted,&nbsp;rtxt);</span></span>
<span class="tr"><span class="th" id="line820">820</span><span class="td">&nbsp;&nbsp;BlkValueCopy(txt,&nbsp;ctxt);</span></span>
<span class="tr"><span class="th" id="line821">821</span><span class="td">&nbsp;&nbsp;BlkValueFree(ctxt);</span></span>
<span class="tr"><span class="th" id="line822">822</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line823">823</span><span class="td">&nbsp;TEXT_TY_Untransmute(rtxt,&nbsp;p,&nbsp;cp);</span></span>
<span class="tr"><span class="th" id="line824">824</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-replace-text">Replace Text.</h3><p><p> This is the general routine which searches for any instance of <span class="fixed">ftxt</span>, as a blob, in <span class="fixed">txt</span>, and replaces it with the text <span class="fixed">rtxt</span>. It works on any of the above blob-types, but two cases are special: first, if the blob-type is <span class="fixed"><a href="./Text.i6t.html#line614">CHR_BLOB</a></span>, then it can do more than search and replace for any instance of a single character: it can search and replace any instance of a substring, so that <span class="fixed">ftxt</span> is not required to be only a single character. Second, if the blob-type is the special value <span class="fixed"><a href="./Text.i6t.html#line621">REGEXP_BLOB</a></span> then <span class="fixed">ftxt</span> is interpreted as a regular expression rather than something literal to find: see <a href="./RegExp.i6t.html">RegExp.i6t</a> for what happens next.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line838">838</span><span class="td">[&nbsp;TEXT_TY_ReplaceText&nbsp;blobtype&nbsp;txt&nbsp;ftxt&nbsp;rtxt</span></span>
<span class="tr"><span class="th" id="line839">839</span><span class="td">&nbsp;r&nbsp;p1&nbsp;p2&nbsp;cp1&nbsp;cp2;</span></span>
<span class="tr"><span class="th" id="line840">840</span><span class="td">&nbsp;TEXT_TY_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line841">841</span><span class="td">&nbsp;cp1&nbsp;=&nbsp;ftxt--&gt;0;&nbsp;p1&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(ftxt);</span></span>
<span class="tr"><span class="th" id="line842">842</span><span class="td">&nbsp;cp2&nbsp;=&nbsp;rtxt--&gt;0;&nbsp;p2&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(rtxt);</span></span>
<span class="tr"><span class="th" id="line843">843</span><span class="td">&nbsp;r&nbsp;=&nbsp;TEXT_TY_ReplaceTextI(blobtype,&nbsp;txt,&nbsp;ftxt,&nbsp;rtxt);</span></span>
<span class="tr"><span class="th" id="line844">844</span><span class="td">&nbsp;TEXT_TY_Untransmute(ftxt,&nbsp;p1,&nbsp;cp1);</span></span>
<span class="tr"><span class="th" id="line845">845</span><span class="td">&nbsp;TEXT_TY_Untransmute(rtxt,&nbsp;p2,&nbsp;cp2);</span></span>
<span class="tr"><span class="th" id="line846">846</span><span class="td">&nbsp;return&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line847">847</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line848">848</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line849">849</span><span class="td">[&nbsp;TEXT_TY_ReplaceTextI&nbsp;blobtype&nbsp;txt&nbsp;ftxt&nbsp;rtxt</span></span>
<span class="tr"><span class="th" id="line850">850</span><span class="td">&nbsp;ctxt&nbsp;csize&nbsp;ilen&nbsp;flen&nbsp;i&nbsp;cl&nbsp;mpos&nbsp;ch&nbsp;chm&nbsp;whitespace&nbsp;punctuation;</span></span>
<span class="tr"><span class="th" id="line851">851</span><span class="td">&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;REGEXP_BLOB&nbsp;or&nbsp;CHR_BLOB)&nbsp;</span></span>
<span class="tr"><span class="th" id="line852">852</span><span class="td">&nbsp;&nbsp;return&nbsp;TEXT_TY_Replace_RE(blobtype,&nbsp;txt,&nbsp;ftxt,&nbsp;rtxt);</span></span>
<span class="tr"><span class="th" id="line853">853</span><span class="td">&nbsp;</span></span>
<span class="tr"><span class="th" id="line854">854</span><span class="td">&nbsp;ilen&nbsp;=&nbsp;TEXT_TY_CharacterLength(txt);</span></span>
<span class="tr"><span class="th" id="line855">855</span><span class="td">&nbsp;flen&nbsp;=&nbsp;TEXT_TY_CharacterLength(ftxt);</span></span>
<span class="tr"><span class="th" id="line856">856</span><span class="td">&nbsp;ctxt&nbsp;=&nbsp;BlkValueCreate(TEXT_TY);</span></span>
<span class="tr"><span class="th" id="line857">857</span><span class="td">&nbsp;TEXT_TY_Transmute(ctxt);</span></span>
<span class="tr"><span class="th" id="line858">858</span><span class="td">&nbsp;csize&nbsp;=&nbsp;BlkValueLBCapacity(ctxt);</span></span>
<span class="tr"><span class="th" id="line859">859</span><span class="td">&nbsp;mpos&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line860">860</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line861">861</span><span class="td">&nbsp;whitespace&nbsp;=&nbsp;true;&nbsp;punctuation&nbsp;=&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line862">862</span><span class="td">&nbsp;for&nbsp;(i=0:i&lt;=ilen:i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line863">863</span><span class="td">&nbsp;&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;i);</span></span>
<span class="tr"><span class="th" id="line864">864</span><span class="td">&nbsp;&nbsp;.MoreMatching;</span></span>
<span class="tr"><span class="th" id="line865">865</span><span class="td">&nbsp;&nbsp;chm&nbsp;=&nbsp;BlkValueRead(ftxt,&nbsp;mpos++);</span></span>
<span class="tr"><span class="th" id="line866">866</span><span class="td">&nbsp;&nbsp;if&nbsp;(mpos&nbsp;==&nbsp;1)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line867">867</span><span class="td">&nbsp;&nbsp;&nbsp;switch&nbsp;(blobtype)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line868">868</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;WORD_BLOB:</span></span>
<span class="tr"><span class="th" id="line869">869</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((whitespace&nbsp;==&nbsp;false)&nbsp;&amp;&amp;&nbsp;(punctuation&nbsp;==&nbsp;false))&nbsp;chm&nbsp;=&nbsp;-1;</span></span>
<span class="tr"><span class="th" id="line870">870</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line871">871</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line872">872</span><span class="td">&nbsp;&nbsp;whitespace&nbsp;=&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line873">873</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;10&nbsp;or&nbsp;13&nbsp;or&nbsp;32&nbsp;or&nbsp;9)&nbsp;whitespace&nbsp;=&nbsp;true;</span></span>
<span class="tr"><span class="th" id="line874">874</span><span class="td">&nbsp;&nbsp;punctuation&nbsp;=&nbsp;false;</span></span>
<span class="tr"><span class="th" id="line875">875</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;&#39;.&#39;&nbsp;or&nbsp;&#39;,&#39;&nbsp;or&nbsp;&#39;!&#39;&nbsp;or&nbsp;&#39;?&#39;</span></span>
<span class="tr"><span class="th" id="line876">876</span><span class="td">&nbsp;&nbsp;&nbsp;or&nbsp;&#39;-&#39;&nbsp;or&nbsp;&#39;/&#39;&nbsp;or&nbsp;&#39;&quot;&#39;&nbsp;or&nbsp;&#39;:&#39;&nbsp;or&nbsp;&#39;;&#39;</span></span>
<span class="tr"><span class="th" id="line877">877</span><span class="td">&nbsp;&nbsp;&nbsp;or&nbsp;&#39;(&#39;&nbsp;or&nbsp;&#39;)&#39;&nbsp;or&nbsp;&#39;[&#39;&nbsp;or&nbsp;&#39;]&#39;&nbsp;or&nbsp;&#39;{&#39;&nbsp;or&nbsp;&#39;}&#39;)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line878">878</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(blobtype&nbsp;==&nbsp;WORD_BLOB)&nbsp;chm&nbsp;=&nbsp;-1;</span></span>
<span class="tr"><span class="th" id="line879">879</span><span class="td">&nbsp;&nbsp;&nbsp;punctuation&nbsp;=&nbsp;true;</span></span>
<span class="tr"><span class="th" id="line880">880</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line881">881</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;chm)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line882">882</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(mpos&nbsp;==&nbsp;flen)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line883">883</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;==&nbsp;ilen)&nbsp;chm&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line884">884</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;chm&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;i+1);</span></span>
<span class="tr"><span class="th" id="line885">885</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((blobtype&nbsp;==&nbsp;CHR_BLOB)&nbsp;||</span></span>
<span class="tr"><span class="th" id="line886">886</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(chm&nbsp;==&nbsp;0&nbsp;or&nbsp;10&nbsp;or&nbsp;13&nbsp;or&nbsp;32&nbsp;or&nbsp;9)&nbsp;||</span></span>
<span class="tr"><span class="th" id="line887">887</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(chm&nbsp;==&nbsp;&#39;.&#39;&nbsp;or&nbsp;&#39;,&#39;&nbsp;or&nbsp;&#39;!&#39;&nbsp;or&nbsp;&#39;?&#39;</span></span>
<span class="tr"><span class="th" id="line888">888</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&#39;-&#39;&nbsp;or&nbsp;&#39;/&#39;&nbsp;or&nbsp;&#39;&quot;&#39;&nbsp;or&nbsp;&#39;:&#39;&nbsp;or&nbsp;&#39;;&#39;</span></span>
<span class="tr"><span class="th" id="line889">889</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&#39;(&#39;&nbsp;or&nbsp;&#39;)&#39;&nbsp;or&nbsp;&#39;[&#39;&nbsp;or&nbsp;&#39;]&#39;&nbsp;or&nbsp;&#39;{&#39;&nbsp;or&nbsp;&#39;}&#39;))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line890">890</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mpos&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line891">891</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;=&nbsp;cl&nbsp;-&nbsp;(flen-1);</span></span>
<span class="tr"><span class="th" id="line892">892</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;cl,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line893">893</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TEXT_TY_Concatenate(ctxt,&nbsp;rtxt,&nbsp;CHR_BLOB);</span></span>
<span class="tr"><span class="th" id="line894">894</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;csize&nbsp;=&nbsp;BlkValueLBCapacity(ctxt);</span></span>
<span class="tr"><span class="th" id="line895">895</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl&nbsp;=&nbsp;TEXT_TY_CharacterLength(ctxt);</span></span>
<span class="tr"><span class="th" id="line896">896</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;</span></span>
<span class="tr"><span class="th" id="line897">897</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line898">898</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line899">899</span><span class="td">&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line900">900</span><span class="td">&nbsp;&nbsp;&nbsp;mpos&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line901">901</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line902">902</span><span class="td">&nbsp;&nbsp;if&nbsp;(cl+1&nbsp;&gt;=&nbsp;csize)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line903">903</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(ctxt,&nbsp;2*cl)&nbsp;==&nbsp;false)&nbsp;break;</span></span>
<span class="tr"><span class="th" id="line904">904</span><span class="td">&nbsp;&nbsp;&nbsp;csize&nbsp;=&nbsp;BlkValueLBCapacity(ctxt);</span></span>
<span class="tr"><span class="th" id="line905">905</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line906">906</span><span class="td">&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;cl++,&nbsp;ch);</span></span>
<span class="tr"><span class="th" id="line907">907</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line908">908</span><span class="td">&nbsp;BlkValueCopy(txt,&nbsp;ctxt);&nbsp;</span></span>
<span class="tr"><span class="th" id="line909">909</span><span class="td">&nbsp;BlkValueFree(ctxt);</span></span>
<span class="tr"><span class="th" id="line910">910</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-character-length">Character Length.</h3><p><p> When accessing at the character-by-character level, things are much easier and we needn&#39;t go through any finite state machine palaver.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line917">917</span><span class="td">[&nbsp;TEXT_TY_CharacterLength&nbsp;txt&nbsp;ch&nbsp;i&nbsp;dsize&nbsp;p&nbsp;cp&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line918">918</span><span class="td">&nbsp;if&nbsp;(txt==0)&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line919">919</span><span class="td">&nbsp;cp&nbsp;=&nbsp;txt--&gt;0;&nbsp;p&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line920">920</span><span class="td">&nbsp;dsize&nbsp;=&nbsp;BlkValueLBCapacity(txt);&nbsp;r&nbsp;=&nbsp;dsize;</span></span>
<span class="tr"><span class="th" id="line921">921</span><span class="td">&nbsp;for&nbsp;(i=0:i&lt;dsize:i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line922">922</span><span class="td">&nbsp;&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;i);</span></span>
<span class="tr"><span class="th" id="line923">923</span><span class="td">&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;0)&nbsp;{&nbsp;r&nbsp;=&nbsp;i;&nbsp;break;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line924">924</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line925">925</span><span class="td">&nbsp;TEXT_TY_Untransmute(txt,&nbsp;p,&nbsp;cp);</span></span>
<span class="tr"><span class="th" id="line926">926</span><span class="td">&nbsp;return&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line927">927</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line928">928</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line929">929</span><span class="td">[&nbsp;TEXT_TY_Empty&nbsp;txt;</span></span>
<span class="tr"><span class="th" id="line930">930</span><span class="td">&nbsp;if&nbsp;(txt==0)&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line931">931</span><span class="td">&nbsp;if&nbsp;(txt--&gt;0&nbsp;&amp;&nbsp;BLK_BVBITMAP_LONGBLOCKMASK&nbsp;==&nbsp;0)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line932">932</span><span class="td">&nbsp;&nbsp;if&nbsp;(txt--&gt;1&nbsp;==&nbsp;EMPTY_TEXT_PACKED)&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line933">933</span><span class="td">&nbsp;&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line934">934</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line935">935</span><span class="td">&nbsp;if&nbsp;(TEXT_TY_CharacterLength(txt)&nbsp;==&nbsp;0)&nbsp;rtrue;</span></span>
<span class="tr"><span class="th" id="line936">936</span><span class="td">&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line937">937</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-get-character">Get Character.</h3><p><p> Characters in a text are numbered upwards from 1 by the users of this routine: which is why we subtract 1 when reading the array in the block-value, which counts from 0.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line945">945</span><span class="td">[&nbsp;TEXT_TY_GetCharacter&nbsp;ctxt&nbsp;txt&nbsp;i&nbsp;ch&nbsp;p&nbsp;cp;</span></span>
<span class="tr"><span class="th" id="line946">946</span><span class="td">&nbsp;if&nbsp;(txt==0)&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line947">947</span><span class="td">&nbsp;cp&nbsp;=&nbsp;txt--&gt;0;&nbsp;p&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line948">948</span><span class="td">&nbsp;TEXT_TY_Transmute(ctxt);</span></span>
<span class="tr"><span class="th" id="line949">949</span><span class="td">&nbsp;if&nbsp;((i&lt;=0)&nbsp;||&nbsp;(i&gt;TEXT_TY_CharacterLength(txt)))&nbsp;ch&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line950">950</span><span class="td">&nbsp;else&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;i-1);</span></span>
<span class="tr"><span class="th" id="line951">951</span><span class="td">&nbsp;BlkValueWrite(ctxt,&nbsp;0,&nbsp;ch);</span></span>
<span class="tr"><span class="th" id="line952">952</span><span class="td">&nbsp;BlkValueWrite(ctxt,&nbsp;1,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line953">953</span><span class="td">&nbsp;TEXT_TY_Untransmute(txt,&nbsp;p,&nbsp;cp);</span></span>
<span class="tr"><span class="th" id="line954">954</span><span class="td">&nbsp;return&nbsp;ctxt;</span></span>
<span class="tr"><span class="th" id="line955">955</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-casing">Casing.</h3><p><p> In many programming languages, characters are a distinct data type from strings, but not in I7. To I7, a character is simply a text which happens to have length 1 &ndash; this has its inefficiencies, but is conceptually easy for the user.<p></p><p><span class="fixed"><a href="./Text.i6t.html#line972">TEXT_TY_CharactersOfCase(txt, case)</a></span> determines whether all the characters in <span class="fixed">txt</span><br> are letters of the given casing: 0 for lower case, 1 for upper case. In the case of ZSCII, this is done correctly handling all of the European accented letters; in the case of Unicode, it follows the Unicode standard.<p></p><p> Note that there is no requirement for <span class="fixed">txt</span> to be only a single character long.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line972">972</span><span class="td">[&nbsp;TEXT_TY_CharactersOfCase&nbsp;txt&nbsp;case&nbsp;i&nbsp;ch&nbsp;len&nbsp;p&nbsp;cp&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line973">973</span><span class="td">&nbsp;if&nbsp;(txt==0)&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line974">974</span><span class="td">&nbsp;cp&nbsp;=&nbsp;txt--&gt;0;&nbsp;p&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line975">975</span><span class="td">&nbsp;len&nbsp;=&nbsp;TEXT_TY_CharacterLength(txt);</span></span>
<span class="tr"><span class="th" id="line976">976</span><span class="td">&nbsp;r&nbsp;=&nbsp;true;</span></span>
<span class="tr"><span class="th" id="line977">977</span><span class="td">&nbsp;for&nbsp;(i=0:i&lt;len:i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line978">978</span><span class="td">&nbsp;&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;i);</span></span>
<span class="tr"><span class="th" id="line979">979</span><span class="td">&nbsp;&nbsp;if&nbsp;((ch)&nbsp;&amp;&amp;&nbsp;(CharIsOfCase(ch,&nbsp;case)&nbsp;==&nbsp;false))&nbsp;{&nbsp;r&nbsp;=&nbsp;false;&nbsp;break;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line980">980</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line981">981</span><span class="td">&nbsp;TEXT_TY_Untransmute(txt,&nbsp;p,&nbsp;cp);</span></span>
<span class="tr"><span class="th" id="line982">982</span><span class="td">&nbsp;return&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line983">983</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-change-case">Change Case.</h3><p><p> We set <span class="fixed">ctxt</span> to the text in <span class="fixed">txt</span>, except that all the letters are converted to the <span class="fixed">case</span> given (0 for lower, 1 for upper). The definition of what is a &quot;letter&quot;, what case it has and what the other-case form is are as specified in the ZSCII and Unicode standards.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line992">992</span><span class="td">[&nbsp;TEXT_TY_CharactersToCase&nbsp;ctxt&nbsp;txt&nbsp;case&nbsp;i&nbsp;ch&nbsp;len&nbsp;bnd&nbsp;pk&nbsp;cp;</span></span>
<span class="tr"><span class="th" id="line993">993</span><span class="td">&nbsp;if&nbsp;(txt==0)&nbsp;return&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line994">994</span><span class="td">&nbsp;cp&nbsp;=&nbsp;txt--&gt;0;&nbsp;pk&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(txt);</span></span>
<span class="tr"><span class="th" id="line995">995</span><span class="td">&nbsp;TEXT_TY_Transmute(ctxt);</span></span>
<span class="tr"><span class="th" id="line996">996</span><span class="td">&nbsp;len&nbsp;=&nbsp;TEXT_TY_CharacterLength(txt);</span></span>
<span class="tr"><span class="th" id="line997">997</span><span class="td">&nbsp;if&nbsp;(BlkValueSetLBCapacity(ctxt,&nbsp;len+1))&nbsp;{</span></span>
<span class="tr"><span class="th" id="line998">998</span><span class="td">&nbsp;&nbsp;bnd&nbsp;=&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line999">999</span><span class="td">&nbsp;&nbsp;for&nbsp;(i=0:i&lt;len:i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line1000">1000</span><span class="td">&nbsp;&nbsp;&nbsp;ch&nbsp;=&nbsp;BlkValueRead(txt,&nbsp;i);</span></span>
<span class="tr"><span class="th" id="line1001">1001</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(case&nbsp;&lt;&nbsp;2)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line1002">1002</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;i,&nbsp;CharToCase(ch,&nbsp;case));</span></span>
<span class="tr"><span class="th" id="line1003">1003</span><span class="td">&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line1004">1004</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;i,&nbsp;CharToCase(ch,&nbsp;bnd));</span></span>
<span class="tr"><span class="th" id="line1005">1005</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(case&nbsp;==&nbsp;2)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line1006">1006</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bnd&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line1007">1007</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;0&nbsp;or&nbsp;10&nbsp;or&nbsp;13&nbsp;or&nbsp;32&nbsp;or&nbsp;9</span></span>
<span class="tr"><span class="th" id="line1008">1008</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&#39;.&#39;&nbsp;or&nbsp;&#39;,&#39;&nbsp;or&nbsp;&#39;!&#39;&nbsp;or&nbsp;&#39;?&#39;</span></span>
<span class="tr"><span class="th" id="line1009">1009</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&#39;-&#39;&nbsp;or&nbsp;&#39;/&#39;&nbsp;or&nbsp;&#39;&quot;&#39;&nbsp;or&nbsp;&#39;:&#39;&nbsp;or&nbsp;&#39;;&#39;</span></span>
<span class="tr"><span class="th" id="line1010">1010</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&#39;(&#39;&nbsp;or&nbsp;&#39;)&#39;&nbsp;or&nbsp;&#39;[&#39;&nbsp;or&nbsp;&#39;]&#39;&nbsp;or&nbsp;&#39;{&#39;&nbsp;or&nbsp;&#39;}&#39;)&nbsp;bnd&nbsp;=&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line1011">1011</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1012">1012</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(case&nbsp;==&nbsp;3)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line1013">1013</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ch&nbsp;~=&nbsp;0&nbsp;or&nbsp;10&nbsp;or&nbsp;13&nbsp;or&nbsp;32&nbsp;or&nbsp;9)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line1014">1014</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bnd&nbsp;==&nbsp;1)&nbsp;bnd&nbsp;=&nbsp;0;</span></span>
<span class="tr"><span class="th" id="line1015">1015</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{</span></span>
<span class="tr"><span class="th" id="line1016">1016</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ch&nbsp;==&nbsp;&#39;.&#39;&nbsp;or&nbsp;&#39;!&#39;&nbsp;or&nbsp;&#39;?&#39;)&nbsp;bnd&nbsp;=&nbsp;1;</span></span>
<span class="tr"><span class="th" id="line1017">1017</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1018">1018</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1019">1019</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1020">1020</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1021">1021</span><span class="td">&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1022">1022</span><span class="td">&nbsp;&nbsp;BlkValueWrite(ctxt,&nbsp;len,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line1023">1023</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1024">1024</span><span class="td">&nbsp;TEXT_TY_Untransmute(txt,&nbsp;pk,&nbsp;cp);</span></span>
<span class="tr"><span class="th" id="line1025">1025</span><span class="td">&nbsp;return&nbsp;ctxt;</span></span>
<span class="tr"><span class="th" id="line1026">1026</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-concatenation">Concatenation.</h3><p><p> To concatenate two texts is to place one after the other: thus &quot;green&quot;concatenated with &quot;horn&quot; makes &quot;greenhorn&quot;. In this routine, <span class="fixed">from_txt</span><br> would be &quot;horn&quot;, and is added at the end of <span class="fixed">to_txt</span>, which is returned in its expanded state.<p></p><p> When the blob type is <span class="fixed"><a href="./Text.i6t.html#line621">REGEXP_BLOB</a></span>, the routine is used not for simple concatenation but to handle the concatenations occurring when a regular expression search-and-replace is going on: see <a href="./RegExp.i6t.html">RegExp.i6t</a>.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line1039">1039</span><span class="td">[&nbsp;TEXT_TY_Concatenate&nbsp;to_txt&nbsp;from_txt&nbsp;blobtype&nbsp;ref_txt</span></span>
<span class="tr"><span class="th" id="line1040">1040</span><span class="td">&nbsp;p&nbsp;cp&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line1041">1041</span><span class="td">&nbsp;if&nbsp;(to_txt==0)&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line1042">1042</span><span class="td">&nbsp;if&nbsp;(from_txt==0)&nbsp;return&nbsp;to_txt;</span></span>
<span class="tr"><span class="th" id="line1043">1043</span><span class="td">&nbsp;TEXT_TY_Transmute(to_txt);</span></span>
<span class="tr"><span class="th" id="line1044">1044</span><span class="td">&nbsp;cp&nbsp;=&nbsp;from_txt--&gt;0;&nbsp;p&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(from_txt);</span></span>
<span class="tr"><span class="th" id="line1045">1045</span><span class="td">&nbsp;r&nbsp;=&nbsp;TEXT_TY_ConcatenateI(to_txt,&nbsp;from_txt,&nbsp;blobtype,&nbsp;ref_txt);</span></span>
<span class="tr"><span class="th" id="line1046">1046</span><span class="td">&nbsp;TEXT_TY_Untransmute(from_txt,&nbsp;p,&nbsp;cp);</span></span>
<span class="tr"><span class="th" id="line1047">1047</span><span class="td">&nbsp;return&nbsp;r;</span></span>
<span class="tr"><span class="th" id="line1048">1048</span><span class="td">];</span></span>
<span class="tr"><span class="th" id="line1049">1049</span><span class="td"></span></span>
<span class="tr"><span class="th" id="line1050">1050</span><span class="td">[&nbsp;TEXT_TY_ConcatenateI&nbsp;to_txt&nbsp;from_txt&nbsp;blobtype&nbsp;ref_txt</span></span>
<span class="tr"><span class="th" id="line1051">1051</span><span class="td">&nbsp;pos&nbsp;len&nbsp;ch&nbsp;i&nbsp;tosize&nbsp;x&nbsp;y&nbsp;case;</span></span>
<span class="tr"><span class="th" id="line1052">1052</span><span class="td">&nbsp;switch(blobtype)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line1053">1053</span><span class="td">&nbsp;&nbsp;CHR_BLOB,&nbsp;0:</span></span>
<span class="tr"><span class="th" id="line1054">1054</span><span class="td">&nbsp;&nbsp;&nbsp;pos&nbsp;=&nbsp;TEXT_TY_CharacterLength(to_txt);</span></span>
<span class="tr"><span class="th" id="line1055">1055</span><span class="td">&nbsp;&nbsp;&nbsp;len&nbsp;=&nbsp;TEXT_TY_CharacterLength(from_txt);</span></span>
<span class="tr"><span class="th" id="line1056">1056</span><span class="td">&nbsp;&nbsp;&nbsp;if&nbsp;(BlkValueSetLBCapacity(to_txt,&nbsp;pos+len+1)&nbsp;==&nbsp;false)&nbsp;return&nbsp;to_txt;</span></span>
<span class="tr"><span class="th" id="line1057">1057</span><span class="td">&nbsp;&nbsp;&nbsp;for&nbsp;(i=0:i&lt;len:i++)&nbsp;{</span></span>
<span class="tr"><span class="th" id="line1058">1058</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;ch&nbsp;=&nbsp;BlkValueRead(from_txt,&nbsp;i);</span></span>
<span class="tr"><span class="th" id="line1059">1059</span><span class="td">&nbsp;&nbsp;&nbsp;&nbsp;BlkValueWrite(to_txt,&nbsp;i+pos,&nbsp;ch);</span></span>
<span class="tr"><span class="th" id="line1060">1060</span><span class="td">&nbsp;&nbsp;&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1061">1061</span><span class="td">&nbsp;&nbsp;&nbsp;BlkValueWrite(to_txt,&nbsp;len+pos,&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line1062">1062</span><span class="td">&nbsp;&nbsp;&nbsp;return&nbsp;to_txt;</span></span>
<span class="tr"><span class="th" id="line1063">1063</span><span class="td">&nbsp;&nbsp;REGEXP_BLOB:</span></span>
<span class="tr"><span class="th" id="line1064">1064</span><span class="td">&nbsp;&nbsp;&nbsp;return&nbsp;TEXT_TY_RE_Concatenate(to_txt,&nbsp;from_txt,&nbsp;blobtype,&nbsp;ref_txt);</span></span>
<span class="tr"><span class="th" id="line1065">1065</span><span class="td">&nbsp;}</span></span>
<span class="tr"><span class="th" id="line1066">1066</span><span class="td">&nbsp;print&nbsp;&quot;***&nbsp;TEXT_TY_Concatenate&nbsp;used&nbsp;on&nbsp;impossible&nbsp;blob&nbsp;type&nbsp;***^&quot;;</span></span>
<span class="tr"><span class="th" id="line1067">1067</span><span class="td">&nbsp;rfalse;</span></span>
<span class="tr"><span class="th" id="line1068">1068</span><span class="td">];</span></span>
</div><div class='text'>
<h3 id="#text-setting-the-players-command">Setting the Player's Command.</h3><p><p> In effect, the text typed most recently by the player is a sort of text already, though it isn&#39;t in text format, and doesn&#39;t live on the heap.<p></p><p></div><div class="pre">
<span class="tr"><span class="th" id="line1076">1076</span><span class="td">[&nbsp;SetPlayersCommand&nbsp;from_txt&nbsp;i&nbsp;len&nbsp;at&nbsp;p&nbsp;cp;</span></span>
<span class="tr"><span class="th" id="line1077">1077</span><span class="td">&nbsp;cp&nbsp;=&nbsp;from_txt--&gt;0;&nbsp;p&nbsp;=&nbsp;TEXT_TY_Temporarily_Transmute(from_txt);</span></span>
<span class="tr"><span class="th" id="line1078">1078</span><span class="td">&nbsp;len&nbsp;=&nbsp;TEXT_TY_CharacterLength(from_txt);</span></span>
<span class="tr"><span class="th" id="line1079">1079</span><span class="td">&nbsp;if&nbsp;(len&nbsp;&gt;&nbsp;118)&nbsp;len&nbsp;=&nbsp;118;</span></span>
<span class="tr"><span class="th" id="line1080">1080</span><span class="td">&nbsp;#ifdef&nbsp;TARGET_ZCODE;</span></span>
<span class="tr"><span class="th" id="line1081">1081</span><span class="td">&nbsp;buffer-&gt;1&nbsp;=&nbsp;len;&nbsp;at&nbsp;=&nbsp;2;</span></span>
<span class="tr"><span class="th" id="line1082">1082</span><span class="td">&nbsp;#ifnot;</span></span>
<span class="tr"><span class="th" id="line1083">1083</span><span class="td">&nbsp;buffer--&gt;0&nbsp;=&nbsp;len;&nbsp;at&nbsp;=&nbsp;4;</span></span>
<span class="tr"><span class="th" id="line1084">1084</span><span class="td">&nbsp;#endif;</span></span>
<span class="tr"><span class="th" id="line1085">1085</span><span class="td">&nbsp;for&nbsp;(i=0:i&lt;len:i++)&nbsp;buffer-&gt;(i+at)&nbsp;=&nbsp;CharToCase(BlkValueRead(from_txt,&nbsp;i),&nbsp;0);</span></span>
<span class="tr"><span class="th" id="line1086">1086</span><span class="td">&nbsp;for&nbsp;(:at+i&lt;120:i++)&nbsp;buffer-&gt;(at+i)&nbsp;=&nbsp;&#39;&nbsp;&#39;;</span></span>
<span class="tr"><span class="th" id="line1087">1087</span><span class="td">&nbsp;VM_Tokenise(buffer,&nbsp;parse);</span></span>
<span class="tr"><span class="th" id="line1088">1088</span><span class="td">&nbsp;players_command&nbsp;=&nbsp;100&nbsp;+&nbsp;WordCount();&nbsp;!&nbsp;The&nbsp;snippet&nbsp;variable&nbsp;&quot;player&#39;s&nbsp;command&quot;</span></span>
<span class="tr"><span class="th" id="line1089">1089</span><span class="td">&nbsp;TEXT_TY_Untransmute(from_txt,&nbsp;p,&nbsp;cp);</span></span>
<span class="tr"><span class="th" id="line1090">1090</span><span class="td">];</span></span>
</div><footer><hr><p><em>From I6T lib 6/12N &copy; Graham Nelson and published under the <a href="https://github.com/zedlopez/standard_rules/blob/main/LICENSE.md">Artistic License 2.0</a>. Distributed with <a href="http://inform7.com/">Inform 7 6M62</a>.</em></p></footer></body></html>
